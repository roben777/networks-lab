\documentclass[12pt]{book}              
%\parindent0pt  \parskip10pt             % make block paragraphs
%\raggedright                            % do not right justify

\usepackage[margin=2cm]{geometry}
\usepackage{enumitem}
%\usepackage{url}
%\usepackage{siunitx}
\usepackage{listings}
\usepackage{graphicx} 
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{verbatim} % adds environment for commenting out blocks of text & for
\usepackage{subcaption} % make it possible to include more than one captioned fi
\usepackage{float}
\usepackage[hyperfootnotes=false]{hyperref}
%\floatstyle{boxed} 
\restylefloat{figure}
\usepackage{tabularx}

\lstset{
%  framexleftmargin=10mm, 
%  tabsize=2,
%  language=c, 
  frame=single,
  numbers=none,
  keepspaces,
%  basicstyle=\footnotesize,
  basicstyle=\scriptsize\ttfamily,
}


%%%% insert figures %%%%
% Args: 1=page in pdf file with figure (1, 2, etc)
% 2=scale factor (1: no scale, 0.5: reduced to 50%, 2:double, etc)
% 3=caption
% NOTE: defines label f-page_nr for each figure
\newcommand{\inspdf}[3]{
\begin{figure}[tb]
\begin{center}
\includegraphics[page=#1, scale=#2]{figs-manual/figs.pdf}
\end{center}
        \caption{#3}\label{f-#1}
\end{figure}
}
\pdfpagebox5

\usepackage{tcolorbox}
\usepackage{xcolor}

\usepackage[
    type={CC},
    modifier={by-sa},
    version={4.0},
]{doclicense}


\title{Computer Networks - Laboratory manual}    % Supply information
\author{Robert Benkoczi, University of Lethbridge}    %   for the title page.
\date{\today\\ version 3.1.0}  %   Use current date. 

%%%%%% macros %%%%%%5
\newcommand{\kathara}{Kathar\'a}

%%% inserting figures 
%%% arg 1: figure file (no directory)
%%% arg 2: scale factor
%%% arg 3: caption
%%% labels are #1.fig
\newcommand{\insfig}[3]{
\begin{figure}[tb]
\begin{center}
\includegraphics[scale=#2]{figs-manual/#1}
\caption{#3\label{#1.fig}}
\end{center}
\end{figure}
}

\setcounter{chapter}{-1}

%\newenvironment{console}
%               {\begin{scriptsize} \begin{verbatim}}{\end{verbatim}  \end{scriptsize}}

%%%%%%%%%%%%%%%%%%%%%%%%

%\renewcommand{\chaptername}{Activity}

% Note that book class by default is formatted to be printed back-to-back.
\begin{document}                        % End of preamble, start of text.
\frontmatter                            % only in book class (roman page #s)
\maketitle    
\doclicenseThis                      
\tableofcontents                        % Print table of contents

\mainmatter % arabic page nrs

\chapter{Introduction}

This manual documents the lab work for course CPSC 3780 Data Communications and Networking at the University of Lethbridge. The lab sessions introduce the students to some of the network management tools currently used in practice. It provide hands-on experience with some basic tasks in network management, using a networking emulation package called \kathara. New to this version is the addition of a network programming component to the lab activities, which will support students with their project activities.


\section{Preparing to run \kathara\ at home}\label{intro.se}

The laboratory experiences in this document use a network emulator called \kathara available at \url{kathara.org}. \kathara is installed in CS labs at the university. You may choose to install \kathara\ on your own computer and you can complete the exercises at home, if you wish. \kathara\ is cross platform, although you need a Pro version for the Windows operating system since \kathara\ uses \emph{Docker} (\url{https://www.docker.com/}).

\subsection{Installing and configuring \emph{\kathara} at home}

This section applies only if you wish to install \kathara\ at home. In the CS laboratory at the university, \kathara\ is already installed.

\begin{tcolorbox}[title=Lab safety note]
  Please exercise common sense when attempting any
  of the commands described in this manual on real computer
  networks. Please consult the UofL policies concerning the use of the
  data network \cite{its-policies} and also be aware of the federal
  laws that govern the use of computers and data networks
  \cite{law-canada,law-us}. 
\end{tcolorbox}

\paragraph{Installing \kathara}

\begin{enumerate}[label=(\arabic*)]
\item You will need root access or admin privileges on
  the computer you are installing \kathara\ on. Please do not execute
  this step on the school network.

\item Visit \url{https://www.kathara.org/} and follow the instructions to install \kathara\ for your operating system \cite{kathara-wiki}.

\item A GUI for creating lab configuration files is available from \url{https://gitlab.com/FedericoYusteenappar/Kathara/-/tree/master}. The GUI is just a more convenient tool to create or alter lab configurations. It is not needed to run \kathara.
  
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%55


\chapter{Lab 1: introduction}

\section{Part 1: \kathara}

\subsection{Objectives}

In this lab, students will learn some basic commands and configuration options to get them started with \kathara. No networks are simulated yet. Some basic familiarity with Linux shell commands is assumed. Students without experience with shell commands will learn during this lab.

\begin{enumerate}[label=Objective \arabic*]
  \item\label{vstart} Students will start a single device (docker container) with \kathara\ and will execute Unix commands including \emph{ifconfig} and \emph{ping}. This tests if their \kathara\ environment is correctly setup.
  \item\label{config} Students will adjust the configuration of their \kathara\ system by changing configuration files.
  \item\label{hosthome} Students will transfer information between their virtual device and the host machine. Students will create files on their virtual devices that can be visible on their host machine, and vice-versa.
  \item\label{image} Students will start and stop the execution of devices using different docker images for \kathara.
    \item\label{bridged} Students will start a virtual device running the \emph{kathara/base} docker image and configured with one network interface linked to their host machine. Students will use test this network link with \emph{ping(6)}. 
\end{enumerate}


\subsection{Summary of commands}

\begin{tabularx}{\textwidth}{r  X}
  Commands & Description \\ \midrule
  ifconfig & lists and configures network interfaces \\
  ip & show / manipulate routing, devices, policy routing and tunnels \\
  ping & tests network connectivity to a remote or to the same computer \\
  nc (netcat) & network cat: transfers data through the network to a remote computer \\ \midrule

  ls & lists the contents of the current directory \\
  cd & changes the current directory \\
  cat & conCATenates the content of the files passed as arguments or takes input from the terminal if no arguments are given \\
  export & exports an environment variable so that it is defined for the current terminal session \\
  whoami & prints the account name for the terminal session\\
  vim, nano & start text editors on devices \\ \midrule
  vstart & starts a \kathara\ virtual device; \emph{-n name} is mandatory \\
  vclean & stops a virtual device;  \emph{-n name} is mandatory \\
  list & lists all running virtual devices \\
  wipe & shuts down all \kathara\ virtual devices\\
\end{tabularx}



\subsection{Lab activities: \ref{vstart}}

\begin{enumerate}[label=Activity \arabic*:]
%%   \item To be able to start a device (virtual machine) successfully, as a first step, we need to define an environment variable that points to the install location for the \kathara\ scripts (step 6 in
%% the Linux installation instructions). In your school network, the kathara environment seems to be properly configured; executing this step may not be necessary. 
    
%% \begin{verbatim}
%% host$ export NETKIT_HOME=/opt/kathara/bin/
%% \end{verbatim}

  %%
%% \item Follow the instructions contained in the document ``Start \kathara\ at school'' under the Laboratory section on Moodle.
  
\item Start your first virtual device (docker container). Give your device a name. The name will appear in the title bar of the terminal opened for that device. In the example below, the name of the device is ``pc''.

  \begin{lstlisting}
host$ kathara vstart -n pc
====================== Starting Device ======================
Deploying devices... |##################################################################| 1/1
\end{lstlisting}
%$
  
\item Your device has started successfully when a new terminal window opens. This terminal window allows to run commands on the virtual device. Try to navigate through the file system for your device. What is the user name for the terminal on the virtual device? Can you see the same set of files in the device window as in a regular terminal window opened on the host machine?

\begin{lstlisting}
root@pc:/# ls
bin   dev  home      lib    media  opt   root  sbin    srv  tmp  var
boot  etc  hosthome  lib64  mnt    proc  run   shared  sys  usr
root@pc:/# cd 
root@pc:~# ls
root@pc:~# pwd
/root
root@pc:~# whoami
root
root@pc:~# 
\end{lstlisting}

\item A network interface is an operating system gadget that allows users interact and configure the behaviour of the OS portion of the OS that deals with the network. To see your network interfaces, run \emph{ifconfig}. Another command that shows the available network interfaces and their assigned IP addresses is \emph{ip address}. What do you notice if you run ifconfig on the virtual device versus when you run it on the host computer? NOTE: \emph{ifconfig} is not available on the kathara host machines in the lab, use \emph{ip address}.

\begin{lstlisting}
root@pc:~# ifconfig
lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
\end{lstlisting}

\item The only network interface available to your virtual device started as illustrated in this lab is \emph{lo}. Find out what this network interface is about by consulting online resources.

\item \emph{ping} is a program that sends a sequence of control packets to the address specified as an argument. It is a standard tool to verify the connectivity between the computer on which ping is executed and the remote computer specified as an argument. The loopback network interface is always available on a device and allows connectivity with the device itself. The name \emph{localhost} identifies the device itself as an address (name actually). We can test the connectivity with the device itself.

\begin{lstlisting}
root@pc:/# ping localhost
PING localhost(localhost (::1)) 56 data bytes
64 bytes from localhost (::1): icmp_seq=1 ttl=64 time=0.019 ms
64 bytes from localhost (::1): icmp_seq=2 ttl=64 time=0.060 ms
64 bytes from localhost (::1): icmp_seq=3 ttl=64 time=0.067 ms
^C
--- localhost ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2028ms
rtt min/avg/max/mdev = 0.019/0.048/0.067/0.022 ms
root@pc:/# 
\end{lstlisting}

\item What inet (IPv4) address is associated with the local host? How about the inet6 (IPv6) address for the local host? Hint: examine the output of the \emph{ifconfig} command. Run \emph{ping} with these addresses instead of the \emph{localhost} name.

  Note that IPv6 is not initially enabled on the virtual devices. To enable IPv6, you will need to edit kathara's configuration file on the host machine. This step is described shortly. Come back to this step after you enable IPv6 and start a new virtual machine.

\item You can shut down a virtual device you created with command \emph{vstart} by running command \emph{vclean}. Shutdown the device you started at the beginning of the lab.

\begin{lstlisting}
$ kathara vstart -n pc1
====================== Starting Device ======================
Deploying devices... |##############################################################################| 1/1
$ kathara vclean -n pc1
Deleting devices... |###############################################################################| 1/1
INFO - Device `pc1` deleted successfully!
\end{lstlisting}
\end{enumerate}

%%%%%%%%%%
\subsection{Lab activities: \ref{image}}

\begin{enumerate}[resume*]
\item The \emph{vstart} command has other options besides the mandatory argument \emph{-n}. Check \url{https://www.kathara.org/man-pages/kathara-vstart.1.html} for the man pages. In this activity, you will experiment with a few options for \emph{vstart}. In particular, we will look at the \emph{--image} option. The virtual device you started is actually a \emph{docker container} \cite{docker-useful}. A docker container is built from an \emph{image} which contains all the software needed for the docker application. When starting a virtual device, the default image used for your device is \emph{kathara/quagga}. This image contains packet routing software, \url{https://quagga.net/}. Some useful network tools, such as \emph{netcat} \cite{netcat}, are not available in the default image.

  Start a virtual device using the \emph{kathara/base} image. Note that the output might differ from the one illustrated below. The new image must be fetched from \url{https:\\hub.docker.com}, which happens automatically when you start the virtual machine.

\begin{lstlisting}
host$ kathara vstart -i kathara/base -n pc2
====================== Starting Device ======================
Deploying devices... |#######################################################################################| 1/1
\end{lstlisting}
%$

\item Go to \url{https://hub.docker.com} and search for images that contain the keyword \emph{kathara}. Start another virtual device using a different image from \emph{quagga} and \emph{base}. Then list your running devices with \emph{kathara list}.

  Note: in the CS lab, the \emph{list} command cannot be carried out because of permissions. You are encouraged to install \kathara\ on your own computer and experiment with the list command as well as docker command.

\begin{lstlisting}
$ kathara list
TIMESTAMP: 2021-09-04 17:02:43.932187


 LAB HASH                USER      DEVICE NAME  STATUS   CPU %  MEM USAGE / LIMIT   MEM %  NET I/O   

 BquVk2860DTFrej8slHuVg  rbenkocz  pc2          running  0.00%  1.85 MB / 15.31 GB  0.01%  0 B / 0 B 

 BquVk2860DTFrej8slHuVg  rbenkocz  pc3          running  0.00%  1.84 MB / 15.31 GB  0.01%  0 B / 0 B 

 BquVk2860DTFrej8slHuVg  rbenkocz  pc           running  0.00%  3.76 MB / 15.31 GB  0.02%  0 B / 0 B 

\end{lstlisting}

%$
\end{enumerate}

\subsection{Lab activities: \ref{config}}

\begin{enumerate}[resume*]
\item For many of the future laboratories, we would like to use the \emph{kathara/base} image. We can change the default behaviour of kathara by editing its configuration file. Open the \emph{~/.config/kathara.conf} file on the host machine and change the default image. \textbf{While we are here, also change the hosthome\_mount option to true and enable ipv6.}
\begin{lstlisting}
{
 "image": "kathara/base",
 "manager_type": "docker",
 "terminal": "/usr/bin/xterm",
 "open_terminals": true,
 "device_shell": "/bin/bash",
 "net_prefix": "kathara",
 "device_prefix": "kathara",
 "debug_level": "INFO",
 "print_startup_log": true,
 "enable_ipv6": true,
 "last_checked": 1630600319.5141602,
 "hosthome_mount": true,
 "shared_mount": true
}
\end{lstlisting}
\end{enumerate}

\subsection{Lab activities: \ref{hosthome}}

\begin{enumerate}[resume*]
\item One important feature of the network emulator is the ability of transferring information (for example network capture files) between the virtual devices and the host computer. On any virtual device, if the \kathara\ configuration option \verb$hosthome_mount$ is enabled, the host computer home directory is accessible to the virtual device via the directory \verb$/hosthome$ on the virtual device.

  \begin{itemize}[label=--]
  \item Create a working folder in your home directory \textbf{on the host computer} named \emph{work1}.
  \item Make sure the \kathara\ configuration option \emph{hosthome\_mount} is enabled.
  \item Make sure you have a virtual device started \emph{after} the hosthome mount option is enabled.
  \item In the terminal window of the virtual device, change to the directory \emph{/hosthome}. What do you see if you list the files there? Navigate to the directory you just created. Use the text editor \emph{nano} to create a text file with some line of text, such as ``Hello world.''.
  \item In the terminal window on the host machine, navigate to the \emph{work1} directory. List it with \emph{ls}. Does the file you created from the virtual device exist and is it accessible on the host machine? Which user owns the file (run \emph{ls -l})? Can you remove it from the host machine? (If not, you can remove it from the virtual device).
  \end{itemize}

\end{enumerate}

\subsection{Lab activities: \ref{bridged}}

\begin{enumerate}[resume*]
\item The virtual devices we started so far have only one network interface enabled, the loopback interface. It is possible to instruct \kathara\ to ``connect'' the virtual device to the host computer via a second network interface on the virtual device. This is achieved with command line option \emph{--bridged} with the \emph{vstart} command.

\begin{lstlisting}
$ kathara vstart -i kathara/base -n pc100 --bridged
====================== Starting Device ======================
INFO - Pulling image `kathara/base:latest`... This may take a while.
Deploying devices... |###############################################################################################| 1/1
$
\end{lstlisting}

\item Use the command \emph{ifconfig} on the virtual device to find out the IP address of the new network interface that connects your device with the host machine. Run \emph{ping} from the host machine to test the connectivity with the virtual device. 

\item When starting a virtual device that is \emph{bridged} with the host computer, a new interface is also created on the host machine. In the lab environment, the name of this interface starts with \emph{docker}. The host machines \emph{beta-kathara} and \emph{gamma-kathara} do not have \emph{ifconfig} installed. Use instead the command \emph{ip address} and identify:
\begin{itemize}[label=-]
\item The IP address of the network interface connected to the virtual device.
\item The real IP address of the host computer (the IP address used in the Internet).
\end{itemize}
Test with \emph{ping} both addresses FROM the virtual device. 
\end{enumerate}

\subsection{Cleanup}

\begin{enumerate}[resume*]
\item Shutdown all the virtual devices you created during the lab. Use \emph{kathara wipe}.

\begin{lstlisting}
$ kathara wipe
Are you sure to wipe Kathara? (y/n) y
$ 
\end{lstlisting}
\end{enumerate}

\section{Exercises}

\begin{enumerate}
\item Start a virtual device named ``mypc'' using the \emph{kathara/base} image. Shut down the virtual device ``mypc''.
\item List the virtual devices started on your host machine (can be done on your personal installation of \kathara\ at home).
\item\label{redirect} Open a terminal window, which can be a terminal
  on the host machine or the terminal for a virtual machine. Run
  command \emph{ls $>$ listing.txt}, which redirects the output of command \emph{ls} to a file, which is, in this case, named \emph{listing.txt}. Examine the contents of the file using the commands \emph{cat} or \emph{less}. 

Check the manual page for command \emph{factor}. Run command \emph{factor} on an integer that has at least 6 digits and redirect the output to a text file named \emph{factors.txt} in your home directory. 

\item Start a virtual device. On the virtual device, run command \emph{ifconfig} and redirect its contents to a file in the work directory on your host machine. List the contents of the file from the host machine. You can use character $>$ followed by the file name to redirect the output of any command, from the console to the specified file (see Exercise \ref{redirect}).

\item Start a virtual device that is \emph{bridged} with the host computer. Find out the IPv6 addresses of the virtual device and the corresponding link local IPv6 address of the host machine. Use IPv6 with \emph{ping6} and perform the tasks below. Note that a link local IPv6 address can only be used to reach network interfaces on the same network, as its name suggests. Routing \footnote{Figuring out the particular network interface that a packet should be sent to in order to reach another network} ignores link local addresses, therefore we need to specify the network interface when using link local addresses. This is done by appending the network interface name to the link local IPv6 address using the \% notation, as in \lstinline$address%interface$. 
\begin{enumerate}[label=(\alph*)]
\item Test the connectivity via IPv6 with \emph{ping6}, from the host machine to the virtual device.
\item Test the connectivity via IPv6 with \emph{ping6}, from the virtual device to the host machine.
\item Are you able to \emph{ping6} the host machine from the virtual device using the link local IPv6 address of the host machine attached to the real network interface? Explain.
\item Are you able to \emph{ping6} the virtual device from the host machine using the link local IPv6 address of the virtual device but with the real network interface of the host machine after the \% character? Explain.
\end{enumerate}

\item Start a virtual device that is \emph{bridged} with the host computer. Start \emph{netcat} on the virtual device in listen mode. Send a message to the \emph{netcat} process on the virtual machine using \emph{netcat} on the host machine. For a short tutorial on \emph{netcat} and how to use it for chat, see \url{https://allabouttesting.org/netcat-tutorial-for-beginners/} or any other relevant online resource.
\end{enumerate}


%%%
\section{Part 2: network programming}

In this part of the lab, students will explore the programming libraries that will help them complete the project for the class. Network programming requires processing asynchronous events and this can be handled with multiple threads of execution. Threads can be avoided with advanced operating system calls such as \emph{select}, but I feel threads can be useful in other situations as well, so there is no harm in learning to program them. We start with basic multi-threaded programming and thread synchronization approaches. 

\subsection{Objectives}

Students will write a C++ program that starts several threads. The program will end when all threads end.

\begin{enumerate}[label=Objective \arabic*]
\item\label{thread.start} Using the C++ STL, students will write code that starts threads of execution.
% \item\label{thread.sleep} Students will write code that can wait (sleep) for a given period of time.
\item\label{mutex} Students will use a mutex object to exclude concurrent execution of portions of the code in a multi-threaded environment.
\item\label{lock.guard} Students will control the mutex through a \lstinline$lock_guard$ object that guarantees a safe lock/unlock mechanism.
\end{enumerate}


\subsection{Summary of routines}

\begin{tabularx}{\textwidth}{r  X}
  C++ Class or routine & Description \\ \midrule
  \lstinline$std::thread$ & spawns a new thread when a thread object is constructed  \\
  %  \lstinline$std::this_thread::sleep_for$ & puts currently running thread to sleep
  \lstinline$std::mutex$ & when locked, any other attempts to lock the mutex by other processes will block the processes \\
  \lstinline$std::lock_guard$ & an object that manages mutexes
\end{tabularx}

\subsection{Lab activities: warm-up}

\begin{enumerate}[label=Activity \arabic*:]
  
\item Consider the following output function:

  \begin{lstlisting}[language=C++]
    void print(int n, char c) {
      for (int i = 0; i < n; i++) {
        std::cout << c << std::flush << ' ' << std::flush;
      }
    }
  \end{lstlisting}

  Examine the code and explain what this function does.

\item Create a working directory and a source file called \emph{sequential.cc} inside. Include the \emph{print} function and define \emph{main} to call \emph{print} twice. An example is shown below. Compile and execute your program.

  \begin{lstlisting}[language=c]
    int main() {
      print(100, 'a');
      print(100, 'b');
      return 0;
    }
  \end{lstlisting}
\end{enumerate}


%% \subsection{Lab activities: \ref{thread.sleep}}

%%   \begin{enumerate}[resume*]
%%   \item We can modify function print to slow it down a little. This will help us appreciate the behaviour of the program once we start using threads. In the for loop of print, instruct the program to sleep for 50 ms after each output character.

%%     \begin{lstlisting}[language=c]
%%       void print(int n, char c) {
%%         for (int i = 0; i < n; i++) {
%%           std::cout << c << ' ' << std::flush;
%%           std::this_thread::sleep_for(std::chrono::milliseconds(50));
%%         }
%%       }
%%     \end{lstlisting}

%%     The output modifier \lstinline$std::flush$ forces the output operator to immediately produce the output. Normally, the output produced by the output stream operator is buffered and there is no guaranteed time when the output is actually sent to the console.

%%   \item Examine the documentation for the helper class \verb$milliseconds$ and for the function \verb$sleep_for$. Use \url{cppreference.com}. Are there any other helper classes to represent duration?

%%   \item Compile and execute the program. Choose other values for the wait time and re-run.
%%   \end{enumerate}


  \subsection{Lab activities: \ref{thread.start}}

  \begin{enumerate}[resume*]
  \item Copy your code from file \emph{sequential.cc}  into a file named \emph{parallel.cc}. Modify the main function to change the first call to print into spawning a thread that executes the print function. Make sure to \lstinline$#include <thread>$. Compile and execute.

    \begin{lstlisting}[language=c]
      int main() {
        std::thread t1(print, 100, 'a');
        print(100, 'b');

        t1.join();
        
        return 0;
      }
    \end{lstlisting}

    Calling \verb$join$ on a thread blocks the calling process until the thread finishes execution.

    \item Change function \verb$main$ so that both print function calls are executed by a parallel thread each.
  \end{enumerate}


  \subsection{Lab activities: \ref{mutex}}

  \begin{enumerate}[resume*]
  \item When we run the \emph{parallel.cc} example, we may notice that the output produced is not always nicely arranged. The console output from one thread may occur between the output of the character and the space of the other thread. Suppose that we consider one iteration of the for loop in \emph{print} a \emph{critical section} and we want to ensure that no other thread is outputting until the iteration ends.

    We can use a mutex (MUTual EXclusion) to limit the parallel execution of portions of the code. See \url{https://riptutorial.com/cplusplus/example/26751/mutexes---thread-safety} for more details.

    Copy the code from file \emph{parallel.cc} into file \emph{parallel-mutex.cc}. Define a mutex object as a global variable. Lock the mutex at the start of the loop iteration, and unlock the mutex at the end.

    \begin{lstlisting}[language=c]
      std::mutex print_mutex;
     
      void print(int n, char c) {
        for (int i = 0; i < n; i++) {
            print_mutex.lock(); 
            std::cout << c << std::flush << ' ' << std::flush;
            print_mutex.unlock();
        }
      }
    \end{lstlisting}

  \item Compile and run. What do you notice?

  \item Modify the code to change the declaration of \lstinline$print_mutex$ from a global variable to a variable local to function \emph{print}. Compile and run. What do you notice

    \item Modify the code back with a globally declared mutex. Then, comment out the call to unlock the mutex. Compile and run. What do you notice. Explain.
  \end{enumerate}


  \subsection{Lab activities: \ref{lock.guard}}

  \begin{enumerate}[resume*]
  \item The lock/unlock mechanism on a mutex is prone to errors. Forgetting to unlock a mutex can lead to a deadlock. In C++, we can manage a mutex using a \lstinline$lock_guard$ object. A lock guard locks a mutex when the lock guard is constructed and unlocks the mutex when the lock guard is destructed.

    Copy the code from file \emph{parallel-mutex.cc} into file \emph{parallel-lock-guard.cc}. Modify the \verb$print$ function as follows.

    \begin{lstlisting}[language=c]
      void print(int n, char c) {
        for (int i = 0; i < n; i++) {
          // this block statement is executed as an atomic operation;
          {
            std::lock_guard<std::mutex> lock(print_mutex); // construction locks the mutex
            std::cout << c << std::flush << ' ' << std::flush;
          }    // destruction unlocks the mutex 
        }
      }
    \end{lstlisting}

    Compile and execute.
  \end{enumerate}

  \subsection{Conclusion}

  Use the thread class to start parallel threads. Declare a mutex and create a \verb$lock_guard$ object to manage the mutex and to avoid concurrent execution of certain portions of your code.


  \section{Exercises}

  \begin{enumerate}[label=\arabic*.]
  \item Write code that spawns 30 parallel threads. Each thread is executing the \verb$print$ function illustrated in the lab activities. Please end the main program when all threads spawned are finished. Submit two source files, one in which a lock guard is used to protect each iteration of the for loop in print, and one where no mutex or lock guard is used. Submit also screen shots with the execution of the two programs. Hint: store thread objects in an array.
  \end{enumerate}

  
%%%%%%%%%%%%%%%%%

\chapter{Lab 2: creating networked devices}

\section{\kathara}

\subsection{Objectives}

Students will start their first local network and will capture and analyze several network packets. 

\begin{enumerate}[label=Objective \arabic*]

\item\label{startstop} Students will start and stop kathara labs using provided lab files; students will work with a lab file that defines a simple local network with two virtual devices.

\item\label{ipv4.2} Students will start the lab and will configure IPv4 addresses on each of the virtual devices. 

\item\label{tcpdump}  Students will use the ping utility to test the local network connectivity between the two hosts created for the lab. Students will use the \emph{tcpdump} command to capture the packets generated by the \emph{ping} command; the students will examine the packets.

\item\label{modifylab} Using the kathara manual page \emph{man kathara-lab.conf}, the students will modify the lab files to add a third device to the network and to automatically configure IPv4 addresses on each device.

\item\label{ipv6.2}  Students will configure IPv6 addresses and will test the
  connectivity using \emph{ping6}. The students will examine the packets generated by the neighbour discovery protocol when IPv6 link local addresses are generated. 

%% \item Students will use the \emph{tcpdump} program to capture network
%%   packets. Students will examine captured packets with
%%   \emph{Wireshark} on their personal computers, or with an online
%%   network packet visualization tool such as
%%   \url{https://hpd.gasmi.net/}. Students will identify the protocols
%%   that participated in the creation of the captured packets. 
\end{enumerate}

\subsection{Summary of new commands}

\begin{tabularx}{\textwidth}{r  X}
  Commands & Description \\ \midrule
  unzip & unpacks the files from a zip archive \\
  tcpdump & captures traffic on a network interface \\
  arp & manipulates  or displays the kernel's IPv4 network neighbour cache \\ \midrule
  lstart & starts a \kathara\ lab \\
  lclean & shuts down a lab
\end{tabularx}


\subsection{Lab activities: \ref{startstop}}\label{2nodes.se}

\begin{enumerate}[label=Activity \arabic*:]
\item Open the Moodle page on the ``Lab resources'' section. Locate the folder named `` `` which contains resources needed to complete the lab activities. Download the zip file titled \emph{2nodes.zip} to a working directory and unpack the files using \emph{unzip}. 
  
\item Change your current directory to the folder where you unpacked
  the lab files. a folder names \emph{2nodes} should be present. Change into that folder. Run \emph{kathara lstart}. Two terminal windows should open, one for each of the two virtual devices.

  \begin{lstlisting}
$ cd 2nodes/
$ kathara lstart
======================= Starting Lab ========================
Name: 2 nodes
Description: Simple local network with two hosts and no network configuration
Version: 2.0
Author(s): Robert Benkoczi
Email: robert.benkoczi@uleth.ca

=============================================================
Deploying collision domains... |##########################################################################| 1/1
Deploying devices... |####################################################################################| 2/2
  \end{lstlisting}

\item Run \emph{ifconfig} on each of the two hosts. How many network interfaces does each device have? What are the IP addresses assigned to these network interfaces?

\item Labs created with \emph{lstart} can be stopped using command \emph{kathara lclean} executed from the lab directory. Try it now, shutdown the lab you just started.

  \begin{lstlisting}
$ kathara lclean
Deleting devices... |#####################################################################################| 2/2
Deleting collision domains... |###########################################################################| 1/1
  \end{lstlisting}

\end{enumerate}

\subsection{Target: \ref{ipv4.2}}\label{ipv4.2.se}
  
\begin{enumerate}[resume*]
\item The \emph{ifconfig} command is used to configure the network interface. Another command that can be used is \emph{ip}. Invoke the manual (on the host machine) to read the documentation, if needed. Configure IPv4 address 10.0.0.1/24 on interface \emph{eth0} for device pc1, running \emph{ifconfig} as shown below.

  \begin{tabular}{r l}
    \toprule
    \multicolumn{2}{l}{\emph{ifconfig} arguments} \\ \midrule
    eth0 & interface name \\
    inet & (optional) address family: inet for IPv4, inet6 for IPv6 \\
    10.0.0.1/24 & IP address to configure \\ \bottomrule
  \end{tabular}

  \begin{lstlisting}
root@pc1:/# ifconfig eth0 inet 10.0.0.1/24
root@pc1:/# ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.0.0.1  netmask 255.255.255.0  broadcast 10.0.0.255
        inet6 fe80::f0f2:2bff:fed8:429d  prefixlen 64  scopeid 0x20<link>
        ether f2:f2:2b:d8:42:9d  txqueuelen 1000  (Ethernet)
        RX packets 66  bytes 9398 (9.1 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 7  bytes 826 (826.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
  \end{lstlisting}

  Note: We use the \emph{10.0.0} network address which is used for private networks (networks that are not expected to communicate with other hosts in the Internet \cite{rfc1918}. We assign host address 1 to pc1 and host address 2 to pc2.

\item Configure IPv4 address 10.0.0.2/24 on pc2.

  \end{enumerate}

%%%
\subsection{Target: \ref{tcpdump}}\label{tcpdump.se}

\begin{enumerate}[resume*]
\item Once the IPv4 addresses for the network interfaces on pc1 and pc2 are configured as documented in Section \ref{ipv4.2.se}, we can test the network connectivity with \emph{ping}. From pc1, we can ping pc2.

  \begin{lstlisting}
root@pc1:/# ping -c 4 10.0.0.2
PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.
64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=0.078 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=64 time=0.123 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=64 time=0.118 ms
64 bytes from 10.0.0.2: icmp_seq=4 ttl=64 time=0.122 ms

--- 10.0.0.2 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3062ms
rtt min/avg/max/mdev = 0.078/0.110/0.123/0.020 ms
  \end{lstlisting}

  %%%
\item We can examine the packets sent and received by \emph{ping} if we capture them using command \emph{tcpdump}:
\begin{enumerate}
\item Start the capture program \emph{tcpdump} on pc2.
\item Run \emph{ping} once more from pc1. Make sure you save the captured packets in a file in sub-directory \emph{/shared} on the virtual device. Files in folder \emph{/shared} on a virtual device are mapped to a folder named \emph{shared} in the lab folder on the host computer.
\item Interrupt the \emph{tcpdump} program on pc2 by pressing CTRL-C.
\end{enumerate}
  More information about \emph{tcpdump} is found in the manual pages \emph{man tcpdump} and several online articles \cite{tcpdump,tcpdump2}.

  \begin{tabularx}{0.9\textwidth}{r X} \toprule
    \multicolumn{2}{l}{\emph{tcpdump} arguments} \\ \midrule
    -i eth0 & which network interface to capture from \\
    -nn & -n tells not to resolve IP addresses into names; with -nn also does not resolve port numbers\\
    -s0 & -s sets the snap length; with 0 the length is unlimited \\
    -w filename & write capture to the specified file \\ \bottomrule
    \end{tabularx}

  \medskip
  \begin{lstlisting}
root@pc2:/# tcpdump -i eth0 -nn -s0 -w /shared/ping.pcap
tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
^C12 packets captured
12 packets received by filter
0 packets dropped by kernel
  \end{lstlisting}

\item\label{icmp} On the host machine, locate the captured file in folder \emph{shared} in the lab folder. Captured packets can be examined with \emph{Wireshark} (not available in the CS Lab) or with an online packet dissector.

  Open \url{https://hpd.gasmi.net} in a browser. Choose the upload button to upload your file with captured packets. Examine the packets, consult online resources, and try to answer the following questions.
  \begin{enumerate}[label=\roman*)]
  \item What protocol is \emph{ping} using? Explain the objectives of the protocol.
  \item Is the protocol using a specific port number? If yes, what number? Revisit the lecture notes from the first week which overview the services offered by the OSI layer and try to justify the choice for the protocol.
  \item Examine the header specific to the protocol used by \emph{ping}. Do you identify several types of packets for the protocol? If yes, list the types of packets and how they are distinguished.
  \end{enumerate}

\item Shutdown the lab. Use \emph{kathara lclean} with the lab directory as the current directory.

\end{enumerate}

%%%%%%%%%%%
\subsection{Target: \ref{modifylab}}

\begin{enumerate}[resume*]
\item First, please make sure no labs are currently running. Run \emph{kathara wipe} if unsure. Copy the directory structure of lab \emph{2nodes} to a different folder named \emph{3nodes}. change the current directory to folder \emph{3nodes}.

  \begin{lstlisting}
$ kathara lclean
A new version of Kathara has been released.
Current: 3.1.0 - Latest: 3.2.0
Please update it from https://github.com/KatharaFramework/Kathara
Deleting devices... |#####################################################################################| 2/2
Deleting collision domains... |###########################################################################| 1/1
$ cd ..
$ ls
2nodes/  2nodes.config  2nodes-ipv6.config  2nodes.zip
$ cp -r 2nodes 3nodes
$ ls
2nodes/  2nodes.config  2nodes-ipv6.config  2nodes.zip  3nodes/
$ cd 3nodes/
$ ls
lab.conf  pc1/  pc1.startup  pc2/  pc2.startup  shared/
  \end{lstlisting}

\item Open \emph{lab.conf} with a text editor. In a different terminal window, open the manual page for \kathara\ labs, \emph{man kathara-lab.conf}. The \emph{lab.conf} sets up the structure of the network. It specifies the hosts (virtual devices), network interfaces, and the collision domains (Ethernet switches) that make up the lab.

  Configurations for each host can be defined in files with extension \emph{.startup}. For example, we will add IPv4 address configuration commands in these files.

  The contents of the \emph{lab.conf} file is the following.

  \lstinputlisting{kathara-labs/2nodes/lab.conf}

  Modify \emph{lab.conf} and add a third host named \emph{pc3} connected to the same collision domain as \emph{pc1} and \emph{pc2}. Also edit the lab metadata, such as title, author, etc.

\item Edit the startup files for \emph{pc1} and \emph{pc2} and add the \emph{ifconfig} command that assigns the appropriate IPv4 addresses to the two hosts. The correct command is already present, in commented form. Uncomment the command. Add the configuration file for \emph{pc3} and assign address 10.0.0.3/24 to \emph{pc3}.

\item Start the new lab. Test if \emph{pc3} is connected to the network. Debug and adjust the lab files if necessary.

\end{enumerate}


%%%
\subsection{Target: \ref{ipv6.2}}\label{ipv6.2.se}

\begin{enumerate}[resume*]
\item Ensure that your lab named \emph{3nodes} is running. Look at the network interface \emph{eth0} for one of the virtual hosts and list the addresses associated with the interface. Are there any global IPv6 addresses assigned to the interface?

\item Run \emph{ping6} from \emph{pc3} to query the connectivity to \emph{pc1}. What is the correct argument to the command?

\item Assign the global IPv6 address 2100::1/64 to \emph{pc1}. Use command \emph{ifconfig} but provide \emph{inet6} as the address family. Note that IPv6 addresses can be added to an interface, but the command must specify the option \emph{add} followed by the address. Similarly, IPv6 addresses can be deleted from an interface. See the man pages \emph{man ifconfig}.

  \begin{lstlisting}
root@pc1:/# ifconfig eth0 inet6 add 2100::1/64
root@pc1:/# ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.0.0.1  netmask 255.255.255.0  broadcast 10.0.0.255
        inet6 fe80::acc1:d4ff:fe1d:b075  prefixlen 64  scopeid 0x20<link>
        inet6 2100::1  prefixlen 64  scopeid 0x0<global>
        ether ae:c1:d4:1d:b0:75  txqueuelen 1000  (Ethernet)
        RX packets 98  bytes 13730 (13.4 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 16  bytes 1896 (1.8 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 4  bytes 280 (280.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 4  bytes 280 (280.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
  \end{lstlisting}

\item Ping6 again from \emph{pc3} to query if \emph{pc1} is connected, but use this time \emph{pc1}'s global address, 2100::1. Can the command be completed? Explain why, or why not.

\item Assign global IPv6 addresses 2100::2/64 and 2100::3/64 to \emph{pc2} and \emph{pc3}, respectively. Try now to ping6 \emph{pc1} from \emph{pc3} using \emph{pc1}'s global IPv6 address. Does the command succeed this time?

  \item Edit the lab files for lab \emph{3nodes} on the host machine so that \emph{pc1}, \emph{pc2}, and \emph{pc3} are automatically assigned the global IPv6 addresses 2100::1, 2100::2, and 2100::3 respectively.
\end{enumerate}

\subsection{Cleanup}

\begin{enumerate}[resume*]
\item The most important activity: before you log out, shutdown any running labs. If you are unsure about which labs you are running, execute \emph{kathara wipe}.
\end{enumerate}


%%%%%%%%
\section{Exercises}

\begin{enumerate}
\item Start your \emph{3nodes} lab with hosts being assigned IPv4 and global IPv6 addresses. Start packet capture on \emph{pc3} and run \emph{ping6} from \emph{pc1} to \emph{pc2}, using link local and then the global IPv6 addresses (see Section \ref{tcpdump.se}). Examine the packets used by \emph{ping6} and compare them with the packets captured for IPv4 in Section \ref{tcpdump.se}. Shutdown the lab at the end.
  
\item With your lab \emph{3nodes} started, run \emph{netcat} over the global IPv6 addresses and send a message from one host to another one. Use UDP or TCP. Shutdown the lab at the end.

\item\label{arp} ARP (Address Resolution Protocol) or how the connection between link layer (Ethernet) and network layer (IPv4) addresses is made. Recall the captured packets for \emph{ping} you obtained in Section \ref{tcpdump.se}. If you re-examine one packet, you notice that the IPv4 header contains the source and destination IPv4 address, and the Ethernet header contains the source and destination Ethernet address. This is because the data link layer (Ethernet) uses Ethernet addresses to identify hosts and communicate with them.

 When the networking stack creates this packet at the source host, it definitely knows the source and destination IPv4 addresses (the destination is given in the \emph{ping} command), and it also knows its own source Ethernet address. But how can it obtain the destination Ethernet address corresponding to the destination IPv4 address? This is needed because the data link layer needs to transmit the frame to the destination by providing the Ethernet address of the destination, if that destination resides on the same local network. You will answer this question in this exercise.

  Perform the following steps.
  \begin{enumerate}[label=(\roman*)]
  \item\label{first.1} Start lab \emph{3nodes}.
  \item Start packet capture with \emph{tcpdump} on, say \emph{pc3}. Remember to save the captured packets in the \emph{/shared} folder on \emph{pc3}.
  \item The operating system maintains a table of neighbour IPv4 / Ethernet addresses called the network neighbour cache. The \emph{arp} command is used to manipulate this table. Examine the manual pages for \emph{arp} (\url{https://www.man7.org/linux/man-pages/man8/arp.8.html} if man arp is not available on the host machine).

    \smallskip
    \begin{tabularx}{0.9\textwidth}{r l} \toprule
      \multicolumn{2}{l}{\emph{arp} command line arguments} \\ \midrule
      $\emptyset$ (no args) & displays the contents of the table \\
      -d address & deletes the  entry corresponding to \emph{address} \\ \bottomrule
    \end{tabularx}
    \smallskip

    Show the arp table from host \emph{pc1}. If it is empty, good!
    
  \item From \emph{pc1}, \emph{ping} \emph{pc2} and show again the arp table from host \emph{pc1}. It should have now an entry for \emph{pc2}'s IPv4 address. This means that your captured packets will show how the data for this new entry was obtained.
    
  \item (optional) If the arp table was not empty before you started the capture, delete the arp entry in \emph{pc1}'s table for \emph{pc2}. Then, from \emph{pc1}, \emph{ping} \emph{pc2}.

  \item\label{last.1} Stop the packet capture, and shutdown the lab. Examine the captured packets with   \url{https://hpd.gasmi.net}.
  \end{enumerate}

  Submit the following:
  \begin{enumerate}[label=(\alph*)]
  \item A briefly commented script corresponding to your commands for steps \ref{first.1} to \ref{last.1} together with the output. Your comments should indicate your purpose for each command.
  \item Explain when entries in the arp table are populated. For example, is the table populated when the host starts up? Is it populated on demand? Etc.
  \item Examine the file with captured packets (.pcap file). Which hosts have placed an ARP request? List the packets containing the ARP request as decoded     by your network packet examination utility.
    \item Examine the pcap file. Which hosts answer each ARP request?
      How is the ARP request delivered and what IPv4
      address is used?
  \item Assume \emph{pc3}'s arp table is empty and, from \emph{pc3}, we \emph{ping} \emph{pc2}. Briefly describe how the ARP packets are exchanged. 
  \end{enumerate}

  %%%%%%%% IPv6 neighbour discovery
\item NDP (Neighbour Discovery Protocol) is a protocol that allows one host to discover the link layer (Ethernet typically) address corresponding to an IPv6 address for a host on the same local network. This exercise is similar to Exercise \ref{arp} but for IPv6 and NDP.

The neighbours table for IPv6 can be examined and manipulated with command \emph{ip}. Please see \url{https://www.linuxtopia.org/online_books/network_administration_guides/Linux+IPv6-HOWTO/Linux_IPv6_HowTo_x1187.html} and also the manual pages, \emph{man ip}.

\smallskip
\begin{tabularx}{0.9\textwidth}{p{5cm} X} \toprule
  \multicolumn{2}{l}{\emph{ip} command line arguments} \\ \midrule
  -6 & use the IPv6 protocol family \\
  neigh & the object manipulated is the neighbours table \\
  show & is a command; it displays the neighbours table \\
  (add/del) IPv6addr lladdr Etheraddr dev device & is a command; it  (adds/deletes) an entry with the specified IPv6 and Ethernet addresses on the given interface\\ \bottomrule
  \end{tabularx}
\smallskip

  Perform the following steps.
  \begin{enumerate}[label=(\roman*)]
  \item Start lab \emph{3nodes}.
  \item Start packet capture with \emph{tcpdump} on, say \emph{pc3}. Remember to save the captured packets in the \emph{/shared} folder on \emph{pc3}.
  \item Examine the contents of the neighbours table on \emph{pc1}.
  \item Make sure there is no entry for \emph{pc2}'s IPv6 address. If there is, delete the entry with \emph{ip -6 neigh del 2100::2 lladdr <Ethernet addr> dev eth0}.
  \item ping6 \emph{pc2} from \emph{pc1}.
  \item Show the neighbours table.
  \item Stop the capture on \emph{pc3}.
    \item Open the pcap file with the online packet reader. 
  \end{enumerate}

      \smallskip
      Submit the following:
  \begin{enumerate}[label=(\alph*)]
  \item A briefly commented script showing your commands described above.
  \item Select the first neighbour solicitation packet. What are the source and destination IPv6 addresses. How about the source and destination Ethernet addresses?
    Consult \url{https://www.computernetworkingnotes.com/networking-tutorials/ipv6-multicast-addresses-explained.html}.
    \item What are the source and destination IP addresses for the reply? Where is the answer stored?
  \end{enumerate}
\end{enumerate}


%%%%%%%%%%%%%%%%%
\chapter{Project lab 2: timers}

In this lab, students will use STL classes to implement the timer functionality needed when programming the typical action-confirmation network protocol behaviour. In this scenario, a process performs an action such as sending a data packet to a peer process, and then it waits to receive a confirmation from the peer process. The confirmation may or may not arrive. If the confirmation arrives, the sending process should resume execution right away. If the confirmation does not arrive, the sending process should resume execution after a maximum wait time (the timer value). The sending process must be able to distinguish the two cases - confirmation received or timer expired. We can implement this behaviour with a \emph{condition variable} object from the STL.

In the second part of the lab, students will design, implement, and test a class whose responsibilities are to manipulate the fields of a packet header.

\section{Objectives}

\begin{enumerate}[label=Objective \arabic*:]
\item\label{unu.l2} Students will explore the signaling features of a condition variable object. Students will also compile and build simple programs using condition variables. 
\item\label{doi.l2} Students will implement an expiration timer using condition variables.
\item\label{trei.l2} Students will design, implement, and test a class responsible for writing and reading the various fields of the header for the course transport protocol. The course transport protocol is the course project for CPSC 3780.
\item\label{patru.l2} Students will use the \emph{Google test} framework (refer to CPSC 2720) to test their class.

\end{enumerate}

\subsection{Summary of classes}

\begin{tabularx}{\textwidth}{r  X}
  Classes & Description \\ \midrule
  \lstinline$std::condition_variable$ & class with various process signaling responsibilities; see \url{https://cplusplus.com/reference/condition_variable/condition_variable/} \\
  \lstinline$std::mutex$ & blocks threads  when trying to lock a mutex more than once\\
  \lstinline$std::unique_lock$ & manages a mutex and implements a more complex locking and unlocking protocol \\
  \lstinline$wait_for$ & member function of condition variable; uses a \lstinline$unique_lock$ to wait for a given period of time or until notified through the condition variable, whichever occurs first
\end{tabularx}


\subsection{Lab activities: \ref{unu.l2}}

A condition variable can be used by threads to signal each other. We can explore these features next.

\begin{enumerate}[label=Activity \arabic*:]

\item\label{pa2.unu} A condition variable can be constructed using the default constructor. Since condition variables are used for signaling, important  member functions are the \emph{notify} functions. 

  Write a program that constructs a condition variable and then notifies the condition variable.

  \lstinputlisting{src/2-timers/2-notify.cc}

\item Compile and execute the program:

  \begin{lstlisting}
$ g++ -o 2-notify -lpthread 2-notify.cc 
$ ./2-notify 
Before notify
After notify
  \end{lstlisting}

  What do you notice? A condition variable can only be constructed using the default constructor. We can then invoke the notify functions, but nothing interesting happens because there is no other thread using the condition variable.

\item Modify the code from \ref{pa2.unu} to create two threads that use the same condition variable.

  \lstinputlisting{src/2-timers/2-threads.cc}

  Compile and run the program several times. What do you notice? Nothing interesting, the threads that call \emph{notify} repeatedly on the condition variable don't seem to be affected by the condition variable.

\item In order for some interaction to happen between threads, one of the threads should \emph{wait} and block on the condition variable. The wait functions require a lock on a mutex to be able to wait.

  Write a program with two threads. One thread, the sleeper, waits on the condition variable. The other notifies the condition variable after a delay of 1 sec. Compile, run, and check that the sleeper thread wakes up.

  \lstinputlisting{src/2-timers/2-sleeper.cc}
\end{enumerate}

\subsection{Lab activities: \ref{doi.l2}}\label{wakesleep.se}


\begin{enumerate}[resume*]  
\item Extend the program above so that the sleeper thread uses the \lstinline$wait_for$ function on the condition variable. Perform the following changes to the source code:
  \begin{itemize}[label=--]
  \item Replace the wait function by \lstinline$wait_for$ in the sleeper thread. The sleeper should wait for 1 sec.
    
  \item Test the return value from the wait function in the sleeper. If the return value equals \lstinline$std::cv_status::timeout$, then the timer expired before the sleeper was notified, otherwise the sleeper was notified and resumed execution. Out a message from the sleeper thread to identify if the sleeper thread was notifies by the waker or if the timer for the wait expired.

  \item In the waker, change the initial wait time from 1 sec to a random value between 0 and 2 sec, so the waker notifies the sleeper after waiting for a randomly chosen period of time. Use the \lstinline$std::rand()$ function to generate a random value between 0 and 2000 milli sec. Use \lstinline$std::srand(std::time(NULL));$ to seed the random number generator.
  \end{itemize}

  Compile the program and run it repeatedly. What do you notice? You should see that in approximately half of the runs, the sleeper timer expires. 
  
\end{enumerate}

\section{Exercises}

\begin{enumerate}
\item Starting from the waker/sleeper source code developed in Section \ref{wakesleep.se}, extend its functions so that the following features are available:
  \begin{enumerate}[label=\alph*)]
  \item There are two sleeper threads.
  \item The waker can randomly choose to wake one of the sleeper threads or the other. The other thread's waiting period expires.
  \item Output messages should clarify which operations are carried out by threads and by which threads. In particular, you should assign an ID to each of the sleeper threads, for example, by passing the ID as an argument to its function.
    \item Explain your approach in a short PDF report: are you using different condition variables? Are you using the same condition variable? Justify your choices. 
  \end{enumerate}
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Lab 3: manual routing tables}

\section{Objectives}

Students will set up routing tables manually so that packets can be exchanged between the three local networks.

\begin{enumerate}[label=Objective \arabic*:]
\item\label{unu} Students will examine the default (empty) routing tables for the lab.
\item\label{addroute} Students will manually add entries in the routing tables to ensure connectivity between LANs.
\item\label{addipv6} Students will configure the lab with IPv6 addresses and restart the lab.
\item\label{ipv6route} Students will populate the routing table for IPv6 using \emph{default} rules. 
\end{enumerate}


\subsection{Summary of new commands}

\begin{tabularx}{\textwidth}{r  X}
  Commands & Description \\ \midrule
  route & displays and modifies routing tables; \emph{man route} for details \\
  route -6 & displays and modifies IPv6 routing tables\\
\end{tabularx}


\section{Lab activities}

%%%
\subsection{Target: \ref{unu}}

\inspdf{1}{1}{Configuration of lab ``3lans''}

\begin{enumerate}[label=Activity \arabic*:]
\item Examine Fig. \ref{f-1} which shows the structure of the network. There are three local networks illustrated by the three edges in the graph. The hosts are represented by rectangles. Each edge (network) is incident to a rectangle to signify that the host is connected to the respective network. The point of incidence represents the host's interface on that network.

  The network prefix for each network is given next to the corresponding edge in the diagram. The host suffix of the IPv4 addresses for each interface is given next to the point representing the interface. The address of an interface is obtained by concatenating the network prefix with the host suffix. For example the IPv4 address of \emph{eth0} for \emph{pc1} is 55.0.0.2.

  What is the address for \emph{eth0} and \emph{eth1} for \emph{r2}?

\item Download the lab files for the lab titled ``3lans'' from the Moodle page and unpack them in a working directory from your account. Start the lab. Examine the IPv4 addresses assigned to the interfaces of virtual devices \emph{pc1} and \emph{r2} and check if they match the diagram in Fig.~\ref{f-1}.

\item From \emph{pc1} ping \emph{r1} using \emph{r1}'s eth0 interface which is connected on the same network. From \emph{pc1} ping \emph{r1}'s eth1 interface. Explain the results. Run \emph{route} to examine the routing tables.
  \begin{lstlisting}
root@pc1:/# ping -c 3 55.0.0.1
PING 55.0.0.1 (55.0.0.1) 56(84) bytes of data.
64 bytes from 55.0.0.1: icmp_seq=1 ttl=64 time=0.238 ms
64 bytes from 55.0.0.1: icmp_seq=2 ttl=64 time=0.109 ms
64 bytes from 55.0.0.1: icmp_seq=3 ttl=64 time=0.136 ms

--- 55.0.0.1 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2027ms
rtt min/avg/max/mdev = 0.109/0.161/0.238/0.055 ms
root@pc1:/# ping -c 3 10.0.0.1
connect: Network is unreachable
root@pc1:/# ^C
root@pc1:/# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
55.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0
root@pc1:/#
  \end{lstlisting}

\item From \emph{r1} ping \emph{pc1} (eth0) and \emph{r2} (eth1). Can \emph{r1} ping \emph{r2}'s eth0? Explain. 

  \begin{lstlisting}
root@r1:/# ping 55.0.0.2
PING 55.0.0.2 (55.0.0.2) 56(84) bytes of data.
64 bytes from 55.0.0.2: icmp_seq=1 ttl=64 time=0.161 ms
64 bytes from 55.0.0.2: icmp_seq=2 ttl=64 time=0.116 ms
64 bytes from 55.0.0.2: icmp_seq=3 ttl=64 time=0.123 ms
^C
--- 55.0.0.2 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2045ms
rtt min/avg/max/mdev = 0.116/0.133/0.161/0.021 ms
root@r1:/# ping -c3 10.0.0.2
PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.
64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=0.073 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=64 time=0.109 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=64 time=0.117 ms

--- 10.0.0.2 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2029ms
rtt min/avg/max/mdev = 0.073/0.099/0.117/0.022 ms
root@r1:/# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth1
55.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0
  \end{lstlisting}
\end{enumerate}


%%%
\subsection{Target: \ref{addroute}}\label{route.ipv4.3.se}

\begin{enumerate}[resume*]
\item We noticed that packets can be sent from a host to destinations that have entries in the routing table (as expected). So, to ping \emph{r1}'s interface eth1 from \emph{pc1}, the routing table at \emph{pc1} should have an entry for \emph{r1}'s eth1 interface, or it should have a default entry (if no matches by other rules, use the default rule to route packets.

  Add an entry for network 10.0.0.0/24 on \emph{pc1}. From \emph{pc1} ping \emph{r1}'s eth1. Do we have success? Why?

  \begin{lstlisting}
root@pc1:/# route add -net 10.0.0.0 netmask 255.255.255.0 gw 55.0.0.1
root@pc1:/# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        55.0.0.1        255.255.255.0   UG    0      0        0 eth0
55.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0
root@pc1:/# ping -c 3 10.0.0.1
PING 10.0.0.1 (10.0.0.1) 56(84) bytes of data.
64 bytes from 10.0.0.1: icmp_seq=1 ttl=64 time=0.178 ms
64 bytes from 10.0.0.1: icmp_seq=2 ttl=64 time=0.118 ms
64 bytes from 10.0.0.1: icmp_seq=3 ttl=64 time=0.116 ms

--- 10.0.0.1 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2052ms
rtt min/avg/max/mdev = 0.116/0.137/0.178/0.030 ms
  \end{lstlisting}

\item We can also configure \emph{pc2}'s routing table so that it can ping \emph{r2}'s interfaces, but this time, add a default entry on \emph{pc2}'s routing table..

  \begin{lstlisting}
root@pc1:/# route add -net 10.0.0.0 netmask 255.255.255.0 gw 55.0.0.1
root@pc1:/# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        55.0.0.1        255.255.255.0   UG    0      0        0 eth0
55.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0
root@pc1:/# ping -c 3 10.0.0.1
PING 10.0.0.1 (10.0.0.1) 56(84) bytes of data.
64 bytes from 10.0.0.1: icmp_seq=1 ttl=64 time=0.178 ms
64 bytes from 10.0.0.1: icmp_seq=2 ttl=64 time=0.118 ms
64 bytes from 10.0.0.1: icmp_seq=3 ttl=64 time=0.116 ms

--- 10.0.0.1 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2052ms
rtt min/avg/max/mdev = 0.116/0.137/0.178/0.030 ms
  \end{lstlisting}

\item We can get more daring. From \emph{pc2} ping \emph{r1}'s eth1 interface. What is happening and why?
  \begin{lstlisting}
root@pc2:/# ping -c3 10.0.0.2
PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.
64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=0.060 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=64 time=0.127 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=64 time=0.128 ms

--- 10.0.0.2 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2040ms
rtt min/avg/max/mdev = 0.060/0.105/0.128/0.031 ms
root@pc2:/# ping -c3 10.0.0.1
PING 10.0.0.1 (10.0.0.1) 56(84) bytes of data.
^C
--- 10.0.0.1 ping statistics ---
3 packets transmitted, 0 received, 100% packet loss, time 2041ms
  \end{lstlisting}

\item So, from \emph{pc2} we can reach r2's interface eth1, but we cannot reach \emph{r1}'s eth1 interface. We see that we, in fact, do reach \emph{r2}'s interface eth1, but the reply from \emph{r1} does not reach \emph{pc2}. We verify this with \emph{tcpdump} from \emph{r1}:

  \begin{lstlisting}
root@r1:/# tcpdump -i eth1
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth1, link-type EN10MB (Ethernet), capture size 262144 bytes
07:39:53.457676 IP 77.0.0.2 > 10.0.0.1: ICMP echo request, id 49, seq 1, length 64
07:39:54.483611 IP 77.0.0.2 > 10.0.0.1: ICMP echo request, id 49, seq 2, length 64
07:39:55.507639 IP 77.0.0.2 > 10.0.0.1: ICMP echo request, id 49, seq 3, length 64
07:39:58.579572 ARP, Request who-has 10.0.0.1 tell 10.0.0.2, length 28
07:39:58.579604 ARP, Reply 10.0.0.1 is-at f2:d1:bf:63:2a:b2 (oui Unknown), length 28
  \end{lstlisting}

\item Fix the routing tables by adding the appropriate entry for 77.0.0.0/24 on \emph{r1}. 
  \begin{lstlisting}
root@r1:/# route add -net 77.0.0.0 netmask 255.255.255.0 gw 10.0.0.2

root@pc2:/# ping -c3 10.0.0.1
PING 10.0.0.1 (10.0.0.1) 56(84) bytes of data.
64 bytes from 10.0.0.1: icmp_seq=1 ttl=63 time=0.205 ms
64 bytes from 10.0.0.1: icmp_seq=2 ttl=63 time=0.138 ms
64 bytes from 10.0.0.1: icmp_seq=3 ttl=63 time=0.138 ms

--- 10.0.0.1 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2038ms
rtt min/avg/max/mdev = 0.138/0.160/0.205/0.033 ms
  \end{lstlisting}

\item Similarly, add an appropriate entry for 55.0.0.0/24 in \emph{r2}'s routing table, so that we can ping \emph{r2}'s eth0 from \emph{pc1}. 

\item Can we now ping \emph{pc2} from \emph{pc1}? What is the state of the routing tables? Do you spot the problem?
  \begin{lstlisting}
root@pc1:/# ping -c 3 77.0.0.2
connect: Network is unreachable
root@pc1:/# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        55.0.0.1        255.255.255.0   UG    0      0        0 eth0
55.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0

root@pc2:/# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         77.0.0.1        0.0.0.0         UG    0      0        0 eth0
77.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0

root@r1:/# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth1
55.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0
77.0.0.0        10.0.0.2        255.255.255.0   UG    0      0        0 eth1

root@r2:/# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth1
55.0.0.0        10.0.0.1        255.255.255.0   UG    0      0        0 eth1
77.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0
  \end{lstlisting}

\item Notice that \emph{pc1} does not know how to route packets for 77.0.0.0/24. We can add an entry for 77.0.0.0/24, or we can replace the entry for 10.0.0.0/24 with a default rule, like for \emph{pc2}.
  \begin{lstlisting}
root@pc1:/# route add -net 77.0.0.0 netmask 255.255.255.0 gw 55.0.0.1
root@pc1:/# ping -c 3 77.0.0.2
PING 77.0.0.2 (77.0.0.2) 56(84) bytes of data.
64 bytes from 77.0.0.2: icmp_seq=1 ttl=62 time=0.086 ms
64 bytes from 77.0.0.2: icmp_seq=2 ttl=62 time=0.062 ms
64 bytes from 77.0.0.2: icmp_seq=3 ttl=62 time=0.121 ms

--- 77.0.0.2 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2037ms
rtt min/avg/max/mdev = 0.062/0.089/0.121/0.026 ms
  \end{lstlisting}

  \item Verify that \emph{pc1} and \emph{pc2} can ping each other. If yes, you have correctly set-up the routing tables for this small network of LANs.
\end{enumerate}

%%
\subsection{Cleanup}

\begin{enumerate}[resume*]
\item The most important activity: before you log out, shutdown any running labs. If you are unsure about which labs you are running, execute \emph{kathara wipe}.
\end{enumerate}

%%%%%%%%%%

\section{Exercises}

\begin{enumerate}
\item Start lab ``3lans''. Can you configure the routing tables for all four devices  using only default rules in such a way that \emph{pc1} is connected to \emph{pc2} and vice-versa?

\item\label{ipv6.3.ex} (Target: \ref{addipv6}) Copy the lab files for ``3lans'' into a new directory named ``3lans.ipv6''. Assign the following IPv6 addresses to the three networks by editing the startup files for the lab (see Section \ref{ipv6.2.se}). The host suffix for the IPv6 addresses should match the host suffix for the IPv4 addresses.

  \begin{tabular}{l l} \toprule
    IPv4 address  & IPv6 address \\ \midrule
    55.0.0.0/24 & 2055::0/64 \\
    10.0.0.0/24 & 2010::0/64 \\
    77.0.0.0/24 & 2077::0/64\\ \bottomrule
  \end{tabular}

  Start lab ``3lans.ipv6'' and ping6 across the local networks to demonstrate that interfaces were correctly set up. Shutdown the lab when done.

\item (Target: \ref{ipv6route}) Start lab ``3lans.ipv6'' (see Exercise \ref{ipv6.3.ex}).
  \begin{enumerate}[label=(\alph*)]
  \item Verify that IPv6 addresses are set appropriately using \emph{ifconfig}. Display the IPv6 routing tables with \emph{route -6}.
  \item Run the lab activities from Section \ref{route.ipv4.3.se} but for IPv6 this time. An example setting the default IPv6 route for \emph{pc1} is given below.
    \begin{lstlisting}
root@pc1:/# ifconfig eth0
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 55.0.0.2  netmask 255.255.255.0  broadcast 55.0.0.255
        inet6 fe80::b425:89ff:fe2e:c35  prefixlen 64  scopeid 0x20<link>
        inet6 2055::2  prefixlen 64  scopeid 0x0<global>
        ether b6:25:89:2e:0c:35  txqueuelen 1000  (Ethernet)
        RX packets 53  bytes 7878 (7.6 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 9  bytes 1122 (1.0 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

root@pc1:/# ping6 -c 3 2055::1
PING 2055::1(2055::1) 56 data bytes
64 bytes from 2055::1: icmp_seq=1 ttl=64 time=0.056 ms
64 bytes from 2055::1: icmp_seq=2 ttl=64 time=0.103 ms
64 bytes from 2055::1: icmp_seq=3 ttl=64 time=0.114 ms

--- 2055::1 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2053ms
rtt min/avg/max/mdev = 0.056/0.091/0.114/0.025 ms
root@pc1:/# ping6 -c 3 2010::1
connect: Network is unreachable
root@pc1:/# route -6 add default gw 2055::1
root@pc1:/# ping6 -c 3 2010::1
PING 2010::1(2010::1) 56 data bytes
64 bytes from 2010::1: icmp_seq=1 ttl=64 time=0.099 ms
64 bytes from 2010::1: icmp_seq=2 ttl=64 time=0.095 ms
64 bytes from 2010::1: icmp_seq=3 ttl=64 time=0.110 ms

--- 2010::1 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2051ms
rtt min/avg/max/mdev = 0.095/0.101/0.110/0.010 ms
    \end{lstlisting}
    
  \item Demonstrate that \emph{pc1} can ping6 \emph{pc2}.
  \end{enumerate}
\end{enumerate}


%%%%%%%%%%%%%%%%%
\chapter{Project lab 3: packet headers, sliding windows}

In this lab, the students will start to develop code for setting and extracting information from binary packet headers. The students will also develop and test the logic for manipulating sequence numbers and sliding windows. Google unit tests will be very useful to test these important project components, and, if students are familiar with test driven development, they can be also used for development.

\section{Objectives}

\begin{enumerate}[label=Objective \arabic*]
  \item\label{pl3.maps} Students will read and create bit header maps for various headers. 
\item\label{pl3.bit} Students will use shift and bit-wise operations to set and get bit fields that are smaller than 8 bits.
\item\label{pl3.byte} Students will use shift, bit-wise, and array access operations to manipulate numerical fields that are multiples of 8 bits, stored in big-endian or network byte order.
\item\label{pl3.head} Students will modify a C++ class that manipulates header fields. Students will use Google tests to test this header management class.
\item\label{pl3.abs} Students will define, on paper, abstract classes for the sliding window protocol for the sender and the receiver.
\item\label{pl3.test} Students will document the behaviour of the sliding window methods using \emph{acceptance tests}.
  \item\label{pl3.impl} Students will implement concrete classes for the sender and receiver sliding window module; students will write Google tests for their acceptance tests.
\end{enumerate}

\subsection{Resources}

\begin{itemize}[label=--]
\item Bit-wise and shift operators in C++: \url{https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/}
\item Google test primer: \url{https://google.github.io/googletest/primer.html}
\item Learning TDD with katas (optional): \url{https://social.technet.microsoft.com/wiki/contents/articles/30940.learning-test-driven-development-with-tdd-katas.aspx}
\end{itemize}


\section{Lab activities}

\subsection{\ref{pl3.maps}}

You can work on the following activities in groups, if you wish.

\begin{enumerate}[label=Activity \arabic*:]
\item Most networking layers add information to the packets they handle. This information is usually added at the beginning of a packet and is stored in binary form, to minimize the length of the packet.

  The structure of the information is represented by a \emph{header map}, a representation that lists the location of various numerical values in a table like format. Columns in this format may identify bits fields. For example, an array of 3 byte values can be shown as follows.

\begin{verbatim}
  0        7
 +----------+
 |  1st val |
 +----------+
 |  2nd val |
 +----------+
 |  3rd val |
 +----------+
\end{verbatim}

An array of two 16 bit numerical values can be shown as follows.
\begin{verbatim}
  0               15
 +-----------------+
 |  1st 16 bit val |
 +-----------------+
 |  2nd 16 bit val |
 +-----------------+
\end{verbatim}

A header containing fields of different sizes: the field \emph{Val} is a 2 bit value stored as the most two significant bits of the first byte in the header; the \emph{payload} is a 16 bit value stored starting with the 16-th bit in the structure.
\begin{verbatim}
 0   1 2   7 8  15 16     31
+=====+=====+=====+=========+
| Val | unu | unu | payload |
|     | sed | sed | length  |
+=====+=====+=====+=========+ 
\end{verbatim}

On a sheet of paper, sketch an updated header map that consists of the Val and payload length fields above + two other 16 bit values, labeled A and B.


\item In the diagrams, small bit indices correspond to the most significant bits in a byte. Similarly, multi-byte values are stored in network order (big endian): most significant byte is stored first (at the lowest numbered byte). For example, if we identify the payload length by its most significant and least significant byte, payload length = MSB LSB, then this will be stored as follows.
\begin{verbatim}
 0   1 2   7 8  15 16  23 24   31
+=====+=====+=====+=============+
| Val | unu | unu | MSB  | LSB  |
|     | sed | sed |      |      |
+=====+=====+=====+=============+ 
\end{verbatim}

Assuming that the unused bits are zero, write the value of the header above in hexadecimal format if Val is 3 and payload length is 0x214a.

\item Suppose we change the header and denote bits 2-7 by X.
\begin{verbatim}
 0   1 2   7 8  15 16  23 24   31
+=====+=====+=====+=============+
| Val |  X  | unu | MSB  | LSB  |
|     |     | sed |      |      |
+=====+=====+=====+=============+ 
\end{verbatim}

Provide the value of the header if Val is 2 (in decimal), X is 51 (in decimal), and payload length is 0x31af (in hexadecimal).
\end{enumerate}


\subsection{\ref{pl3.bit}}

\begin{enumerate}[resume*]
\item Consider the first byte in the header above. Suppose we want to assign  Val the value 2 while keeping the value of X unmodified. Describe a sequence of bitwise operations that achieves this. Recall that all bitwise operations involve byte values. For example, if $b_1 = 1000.0100$ and $b_2 = 0100.1100$ then the bitwise OR between $b_1$ and $b_2$ is $1100.1100$. What is the bitwise AND between $b_1$ and $b_2$?
\begin{verbatim}
 0   1 2   7 
+=====+=====+
| Val |  X  |
|  2  |     |
+=====+=====+
\end{verbatim}

Hint: consider the bitwise OR between 2|0 and 0|X.

\item Describe now the sequence of bitwise operations that sets the field X to some given value $\alpha$, without changing Val.

\item Describe the sequence of bitwise operations that sets Val to some given value $\beta$ while leaving X unchanged.

  Hint: shift $\beta$ to the left by 6 positions.
  
\end{enumerate}


\subsection{\ref{pl3.byte}}

\begin{enumerate}[resume*]
\item Consider the 32 bit header below. View it as an array $b[]$ of 4 byte values. Describe a sequence of assignment operations that set the payload length to the hexadecimal value 0x1234.
 \begin{verbatim}
 0   1 2   7 8  15 16  23 24   31
+=====+=====+=====+=============+
| Val |  X  | unu | MSB  | LSB  |
|     |     | sed |      |      |
+=====+=====+=====+=============+ 
\end{verbatim}

 \item Suppose the payload length is represented by some value $\gamma$. Describe a sequence of operations using assignment and shifts to set the payload length to $\gamma$. 
\end{enumerate}


\subsection{\ref{pl3.head}}

\begin{enumerate}[resume*]
\item Download the header class implementation and the corresponding google tests from the file 2-header.zip on Moodle, under Lab resources / Project source files. Unpack the contents into a working directory.

\item Examine the class header file and read the comments for each member function. 

Answer the following questions about the code:
\begin{enumerate}[label=(\alph*)]
\item Which member function sets the \emph{Val} field of the header?
\item What is the range of values for the \emph{Val} field?
\item What is the documented behaviour for the setter of \emph{Val}? Does the function implement the documented behaviour?
\end{enumerate}
  
\item Read the primer on Google tests, if you are not familiar with this framework.

\item Examine the test code, and identify the functions that are tested.

\item Build the test code using the Makefile provided. Are there any failed tests?

\item Add a test case for the getter of field \emph{Val}. Check if the test passes and correct the code if necessary. Notice that your test should assign a value to the first byte in the header class based on your manual calculation of the field, then it should call the getter.

\item Add a third test case that tests the behaviour of the setter of \emph{Val} when we attempt to set it to a value outside of its range. See that the test fails first, and then fix the code.
\end{enumerate}


\subsection{\ref{pl3.abs}}

\begin{enumerate}[resume*]
\item Revisit the lecture notes about the sliding window protocol with go-back-N. Examine the examples that describe the behaviour of the sender and the receiver as they react to various events. 

\item On a sheet of paper, list the responsibilities you would assign to a class that manages the sequence numbers and the sliding window for the sender. Make another list for the class managing the responses of the receiver. As an example, a partial list for the sender is proposed below.

  \begin{enumerate}[label=R\arabic*.]
  \item Maintain the number of bits the sequence numbers are represented by.
  \item Maintain the maximum size of the sliding window.
  \item Maintain the current size of the sliding window.
  \item Decide if a new sequence number can be assigned to a frame that can be transmitted for the first time (sliding window grows or moves to the right).
  \item Processes acknowledged sequence numbers.
  \item Etc.
  \end{enumerate}

\item Write header files for an abstract class (interface) for the sender sliding window and for the receiver sliding window. Document the class member functions, describing the parameters and the return value. Note that you should not be concerned yet by re-transmission timers or by actually storing segments. Focus only on sequence numbers.

  Example:
  \begin{itemize}[label=--]
  \item constructor(n): n represents the number of bits for sequence numbers.
  \item canAddNew(): returns true if the sliding window can advance or expand to provide a new sequence number for an unconfirmed frame.
  \item addNew(): advances or expands the sliding window by one position, if possible. It returns the new sequence number that the sliding window expanded or advanced to. It returns -1 if the sliding window cannot incorporate a new sequence number (because it is at the maximum size already, for example).
  \item setWinSize(n): sets the max size of the sliding window to n.
  \item acknowledge(s): an acknowledgment for sequence s is received. The number of unacknowledged sequences inside the window may reduce as a result of this function.
  \item nrSeqInWin(): returns the number of unacknowledged sequences in the sliding window.
  \item Etc.
  \end{itemize}
\end{enumerate}


\subsection{\ref{pl3.test}}

\begin{enumerate}[resume*]
\item Using the class definition you created in the previous section, define acceptance tests to document the behaviour of your member functions. An example is provided below. As you develop your acceptance tests, feel free to change your interfaces, if necessary.

  Examples:
  \begin{itemize}[label=--]
  \item For setWinSize:
    \begin{itemize}
    \item setWinSize(0)
      \item canAddNew() should return false
    \end{itemize}
  \item for addNew:
    \begin{itemize}
    \item setWinSize(2);
    \item addNew() should return 0
    \item nrSeqInWin() should return 1
    \item addNew() should return 1
    \item addNew() should return -1
    \item nrSeqInWin() should return 2
    \end{itemize}
  \item for acknowledge:
    \begin{itemize}
    \item setWinSize(2);
    \item addNew() should return 0
    \item nrSeqInWin() should return 1
    \item addNew() should return 1
    \item nrSeqInWin() should return 2
    \item acknowledge(1)
    \item nrSeqInWin() should return 0.
    \end{itemize}
    \item Etc.
  \end{itemize}
\end{enumerate}


\subsection{\ref{pl3.impl}}\label{sec.impl}

\begin{enumerate}[resume*]
\item\label{act.impl} Implement the concrete sliding window classes for the receiver and the sender. Implement the acceptance tests using Google tests. 
\end{enumerate}


\section{Exercises}

\begin{enumerate}[label=\arabic*.]
\item Consider the following header map, taken for the header you need to implement for your project:
\begin{verbatim}
 01 2 3 7 8     15 16     23 24    31
+--+-+---+--------+---------+--------+
|Ty|T|Win|  Seq   |      Length      |
|pe|R|dow|  num   |                  |
+--+-+---+--------+---------+--------+
|        Timestamp (4 bytes)         |
|                                    |
+------------------------------------+
|           CRC1 (4 bytes)           |
|                                    |
+------------------------------------+
|                                    |
|                                    |
+                                    +
.       Payload (max 512 bytes)      .
.                                    .
.                                    .
+------------------------------------+
|     CRC2 (4 bytes, optional)       |
|                                    |
+------------------------------------+
\end{verbatim}

Implement a concrete class that manages the fields from the first 32 bits of this header: Type, TR, Window, Seq num, and Length. Implement setter and getter functions for these fields and test their correctness using Google tests.

You need not know the meaning for these fields, yet. Just consider them to be positive integers from a suitable range of values that depends on their number of bits.

\item Complete Activity \ref{act.impl} from Section \ref{sec.impl}. Implement the behaviour corresponding to the \textbf{selective repeat sliding window protocol}. Can you design your class so that you use the same interface you created for the go-back-N sliding window protocol during the lab activities? 
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\bibliographystyle{plain} \bibliography{labman}

\end{document}
