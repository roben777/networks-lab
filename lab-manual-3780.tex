\documentclass[12pt]{book}              
%\parindent0pt  \parskip10pt             % make block paragraphs
%\raggedright                            % do not right justify

\usepackage[margin=2cm]{geometry}
\usepackage{enumitem}
%\usepackage{url}
\usepackage{siunitx}
\usepackage{listings}
\usepackage{graphicx} 
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{verbatim} % adds environment for commenting out blocks of text & for
\usepackage{subcaption} % make it possible to include more than one captioned fi
\usepackage{float}
\usepackage[hyperfootnotes=false]{hyperref}
%\floatstyle{boxed} 
\restylefloat{figure}
\usepackage{tabularx}

\lstset{
%  framexleftmargin=10mm, 
%  tabsize=2,
%  language=c, 
  frame=single,
  numbers=none,
  keepspaces,
%  basicstyle=\footnotesize,
  basicstyle=\scriptsize\ttfamily,
}


%%%% insert figures %%%%
% Args: 1=page in pdf file with figure (1, 2, etc)
% 2=scale factor (1: no scale, 0.5: reduced to 50%, 2:double, etc)
% 3=caption
% NOTE: defines label f-page_nr for each figure
\newcommand{\inspdf}[3]{
\begin{figure}[tb]
\begin{center}
\includegraphics[page=#1, scale=#2]{figs-manual/figs.pdf}
\end{center}
        \caption{#3}\label{f-#1}
\end{figure}
}
\pdfpagebox5

\usepackage{tcolorbox}
\usepackage{xcolor}

\usepackage[
    type={CC},
    modifier={by-sa},
    version={4.0},
]{doclicense}


\title{Computer Networks - Laboratory manual}    % Supply information
\author{Robert Benkoczi, University of Lethbridge}    %   for the title page.
\date{\today\\ version 3.0}  %   Use current date. 

%%%%%% macros %%%%%%5
\newcommand{\kathara}{Kathar\'a}

%%% inserting figures 
%%% arg 1: figure file (no directory)
%%% arg 2: scale factor
%%% arg 3: caption
%%% labels are #1.fig
\newcommand{\insfig}[3]{
\begin{figure}[tb]
\begin{center}
\includegraphics[scale=#2]{figs-manual/#1}
\caption{#3\label{#1.fig}}
\end{center}
\end{figure}
}

\setcounter{chapter}{-1}

%\newenvironment{console}
%               {\begin{scriptsize} \begin{verbatim}}{\end{verbatim}  \end{scriptsize}}

%%%%%%%%%%%%%%%%%%%%%%%%

%\renewcommand{\chaptername}{Activity}

% Note that book class by default is formatted to be printed back-to-back.
\begin{document}                        % End of preamble, start of text.
\frontmatter                            % only in book class (roman page #s)
\maketitle    
\doclicenseThis                      
\tableofcontents                        % Print table of contents

\mainmatter % arabic page nrs

\chapter{Introduction}

This manual documents the lab work for course CPSC 3780 Data Communications and Networking at the University of Lethbridge. The lab sessions introduce the students to some of the network management tools currently used in practice. It provide hands-on experience with some basic tasks in network management, using a networking emulation package called \kathara. New to this version is the addition of a network programming component to the lab activities, which will support students with their project activities.


\section{Preparing to run \kathara\ at home}\label{intro.se}

The laboratory experiences in this document use a network emulator called \kathara available at \url{kathara.org}. \kathara is installed in CS labs at the univesity. You may choose to install \kathara\ on your own computer and you can complete the exercises at home, if you wish. \kathara\ is cross platform, although you need a Pro version for the Windows operating system since \kathara\ uses \emph{Docker} (\url{https://www.docker.com/}).

\subsection{Installing and configuring \emph{\kathara} at home}

This section applies only if you wish to install \kathara\ at home. In the CS laboratory at the university, \kathara\ is already installed.

\begin{tcolorbox}[title=Lab safety note]
  Please exercise common sense when attempting any
  of the commands described in this manual on real computer
  networks. Please consult the UofL policies concerning the use of the
  data network \cite{its-policies} and also be aware of the federal
  laws that govern the use of computers and data networks
  \cite{law-canada,law-us}. 
\end{tcolorbox}

\paragraph{Installing \kathara}

\begin{enumerate}[label=(\arabic*)]
\item You will need root access or admin privileges on
  the computer you are installing \kathara\ on. Please do not execute
  this step on the school network.

\item Visit \url{https://www.kathara.org/} and follow the instructions to install \kathara\ for your operating system \cite{kathara-wiki}.

\item A GUI for creating lab configuration files is available from \url{https://gitlab.com/FedericoYusteenappar/Kathara/-/tree/master}. The GUI is just a more convenient tool to create or alter lab configurations. I tis not needed to run \kathara.
  
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%55


\chapter{Lab 1: introduction}

\section{Part 1: \kathara}

\subsection{Objectives}

In this lab, students will learn some basic commands and configuration options to get them started with \kathara. No networks are simulated yet. Some basic familiarity with linux shell commands is assumed. Students without experience with shell commands will learn during this lab.

\begin{enumerate}[label=Objective \arabic*]
  \item\label{vstart} Students will start a single device (docker container) with \kathara\ and will execute unix commands including \emph{ifconfig} and \emph{ping}. This tests if their \kathara\ environment is correctly setup.
  \item\label{config} Students will adjust the configuration of their \kathara\ system by changing configuration files.
  \item\label{hosthome} Students will transfer information between their virtual device and the host machine. Students will create files on their virtual devices that can be visible on their host machine, and vice-versa.
  \item\label{image} Students will start and stop the execution of devices using different docker images for \kathara.
    \item\label{bridged} Students will start a virtual device running the \emph{kathara/base} docker image and configured with one network interface linked to their host machine. Students will use test this network link with \emph{ping(6)}. 
\end{enumerate}


\subsection{Summary of commands}

\begin{tabularx}{\textwidth}{r  X}
  Commands & Description \\ \midrule
  ifconfig & lists and configures network interfaces \\
  ip & show / manipulate routing, devices, policy routing and tunnels \\
  ping & tests network connectivity to a remote or to the same computer \\
  nc (netcat) & network cat: transfers data through the network to a remote computer \\ \midrule

  ls & lists the contents of the current directory \\
  cd & changes the current directory \\
  cat & conCATenates the content of the files passed as arguments or takes input from the terminal if no arguments are given \\
  export & exports an environment variable so that it is defined for the current terminal session \\
  whoami & prints the account name for the terminal session\\
  vim, nano & start text editors on devices \\ \midrule
  vstart & starts a \kathara\ virtual device; \emph{-n name} is mandatory \\
  vclean & stops a virtual device;  \emph{-n name} is mandatory \\
  list & lists all running virtual devices \\
  wipe & shuts down all \kathara\ virtual devices\\
\end{tabularx}



\subsection{Lab activities: \ref{vstart}}

\begin{enumerate}[label=Activity \arabic*:]
%%   \item To be able to start a device (virtual machine) successfully, as a first step, we need to define an environment variable that points to the install location for the \kathara\ scripts (step 6 in
%% the Linux installation instructions). In your school network, the kathara environment seems to be properly configured; executing this step may not be necessary. 
    
%% \begin{verbatim}
%% host$ export NETKIT_HOME=/opt/kathara/bin/
%% \end{verbatim}

  %%
%% \item Follow the instructions contained in the document ``Start \kathara\ at school'' under the Laboratory section on Moodle.
  
\item Start your first virtual device (docker container). Give your device a name. The name will appear in the title bar of the terminal opened for that device. In the example below, the name of the device is ``pc''.

  \begin{lstlisting}
host$ kathara vstart -n pc
====================== Starting Device ======================
Deploying devices... |##################################################################| 1/1
\end{lstlisting}
%$
  
\item Your device has started successfully when a new terminal window opens. This terminal window allows to run commands on the virtual device. Try to navigate through the file system for your device. What is the user name for the terminal on the virtual device? Can you see the same set of files in the device window as in a regular terminal window opened on the host machine?

\begin{lstlisting}
root@pc:/# ls
bin   dev  home      lib    media  opt   root  sbin    srv  tmp  var
boot  etc  hosthome  lib64  mnt    proc  run   shared  sys  usr
root@pc:/# cd 
root@pc:~# ls
root@pc:~# pwd
/root
root@pc:~# whoami
root
root@pc:~# 
\end{lstlisting}

\item A network interface is an operating system gadget that allows users interact and configure the behaviour of the OS portion of the OS that deals with the network. To see your network interfaces, run \emph{ifconfig}. Another command that shows the available network interfaces and their assigned IP addresses is \emph{ip address}. What do you notice if you run ifconfig on the virtual device versus when you run it on the host computer? NOTE: \emph{ifconfig} is not available on the kathara host machines in the lab, use \emph{ip address}.

\begin{lstlisting}
root@pc:~# ifconfig
lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
\end{lstlisting}

\item The only network interface available to your virtual device started as illustrated in this lab is \emph{lo}. Find out what this network interface is about by consulting online resources.

\item \emph{ping} is a program that sends a sequence of control packets to the address specified as an argument. It is a standard tool to verify the connectivity between the computer on which ping is executed and the remote computer specified as an argument. The loopback network interface is always available on a device and allows connectivity with the device itself. The name \emph{localhost} identifies the device itself as an address (name actually). We can test the connectivity with the device itself.

\begin{lstlisting}
root@pc:/# ping localhost
PING localhost(localhost (::1)) 56 data bytes
64 bytes from localhost (::1): icmp_seq=1 ttl=64 time=0.019 ms
64 bytes from localhost (::1): icmp_seq=2 ttl=64 time=0.060 ms
64 bytes from localhost (::1): icmp_seq=3 ttl=64 time=0.067 ms
^C
--- localhost ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2028ms
rtt min/avg/max/mdev = 0.019/0.048/0.067/0.022 ms
root@pc:/# 
\end{lstlisting}

\item What inet (IPv4) address is asssociated with the local host? How about the inet6 (IPv6) address for the local host? Hint: examine the output of the \emph{ifconfig} command. Run \emph{ping} with these addresses instead of the \emph{localhost} name.

  Note that IPv6 is not initially enabled on the virtual devices. To enable IPv6, you will need to edit kathara's configuration file on the host machine. This step is described shortly. Come back to this step after you enable IPv6 and start a new virtual machine.

\item You can shut down a virtual device you created with command \emph{vstart} by running command \emph{vclean}. Shutdown the device you started at the beginning of the lab.

\begin{lstlisting}
$ kathara vstart -n pc1
====================== Starting Device ======================
Deploying devices... |##############################################################################| 1/1
$ kathara vclean -n pc1
Deleting devices... |###############################################################################| 1/1
INFO - Device `pc1` deleted successfully!
\end{lstlisting}
\end{enumerate}

%%%%%%%%%%
\subsection{Lab activities: \ref{image}}

\begin{enumerate}[resume*]
\item The \emph{vstart} command has other options besides the mandatory argument \emph{-n}. Check \url{https://www.kathara.org/man-pages/kathara-vstart.1.html} for the man pages. In this activity, you will experiment with a few options for \emph{vstart}. In particular, we will look at the \emph{--image} option. The virtual device you started is actually a \emph{docker container} \cite{docker-useful}. A docker container is built from an \emph{image} which contains all the software needed for the docker application. When starting a virtual device, the default image used for your device is \emph{kathara/quagga}. This image contains packet routing software, \url{https://quagga.net/}. Some useful network tools, such as \emph{netcat} \cite{netcat}, are not available in the default image.

  Start a virtual device using the \emph{kathara/base} image. Note that the output might differ from the one illustrated below. The new image must be fetched from \url{https:\\hub.docker.com}, which happens automatically when you start the virtual machine.

\begin{lstlisting}
host$ kathara vstart -i kathara/base -n pc2
====================== Starting Device ======================
Deploying devices... |#######################################################################################| 1/1
\end{lstlisting}
%$

\item Go to \url{https://hub.docker.com} and search for images that contain the keywork \emph{kathara}. Start another virtual device using a different image from \emph{quagga} and \emph{base}. Then list your running devices with \emph{kathara list}.

  Note: in the CS lab, the \emph{list} command cannot be carried out because of permissions. You are encouraged to install \kathara\ on your own computer and experiment with the list command as well as docker command.

\begin{lstlisting}
$ kathara list
TIMESTAMP: 2021-09-04 17:02:43.932187


 LAB HASH                USER      DEVICE NAME  STATUS   CPU %  MEM USAGE / LIMIT   MEM %  NET I/O   

 BquVk2860DTFrej8slHuVg  rbenkocz  pc2          running  0.00%  1.85 MB / 15.31 GB  0.01%  0 B / 0 B 

 BquVk2860DTFrej8slHuVg  rbenkocz  pc3          running  0.00%  1.84 MB / 15.31 GB  0.01%  0 B / 0 B 

 BquVk2860DTFrej8slHuVg  rbenkocz  pc           running  0.00%  3.76 MB / 15.31 GB  0.02%  0 B / 0 B 

\end{lstlisting}

%$
\end{enumerate}

\subsection{Lab activities: \ref{config}}

\begin{enumerate}[resume*]
\item For many of the future laboratories, we would like to use the \emph{kathara/base} image. We can change the default behaviour of kathara by editing its configuration file. Open the \emph{~/.config/kathara.conf} file on the host machine and change the default image. \textbf{While we are here, also change the hosthome\_mount option to true and enable ipv6.}
\begin{lstlisting}
{
 "image": "kathara/base",
 "manager_type": "docker",
 "terminal": "/usr/bin/xterm",
 "open_terminals": true,
 "device_shell": "/bin/bash",
 "net_prefix": "kathara",
 "device_prefix": "kathara",
 "debug_level": "INFO",
 "print_startup_log": true,
 "enable_ipv6": true,
 "last_checked": 1630600319.5141602,
 "hosthome_mount": true,
 "shared_mount": true
}
\end{lstlisting}
\end{enumerate}

\subsection{Lab activities: \ref{hosthome}}

\begin{enumerate}[resume*]
\item One important feature of the network emulator is the ability of transfering information (for example network capture files) between the virtual devices and the host computer. On any virtual device, if the \kathara\ configuration option \verb$hosthome_mount$ is enabled, the host computer home directory is accessible to the virtual device via the directory \verb$/hosthome$ on the virtual device.

  \begin{itemize}[label=--]
  \item Create a working folder in your home directory \textbf{on the host computer} named \emph{work1}.
  \item Make sure the \kathara\ configuration option \emph{hosthome\_mount} is enabled.
  \item Make sure you have a virtual device started \emph{after} the hosthome mount option is enabled.
  \item In the terminal window of the virtual device, change to the directory \emph{/hosthome}. What do you see if you list the files there? Navigate to the directory you just created. Use the text editor \emph{nano} to create a text file with some line of text, such as ``Hello world.''.
  \item In the terminal window on the host machine, navigate to the \emph{work1} directory. List it with \emph{ls}. Does the file you created from the virtual device exist and is it accessible on the host machine? Which user owns the file (run \emph{ls -l})? Can you remove it from the host machine? (If not, you can remove it from the virtual device).
  \end{itemize}

\end{enumerate}

\subsection{Lab activities: \ref{bridged}}

\begin{enumerate}[resume*]
\item The virtual devices we started so far have only one network interface enabled, the loopback interface. It is possible to instruct \kathara\ to ``connect'' the virtual device to the host computer via a second network interface on the virtual device. This is achieved with command line option \emph{--bridged} with the \emph{vstart} command.

\begin{lstlisting}
$ kathara vstart -i kathara/base -n pc100 --bridged
====================== Starting Device ======================
INFO - Pulling image `kathara/base:latest`... This may take a while.
Deploying devices... |###############################################################################################| 1/1
$
\end{lstlisting}

\item Use the command \emph{ifconfig} on the virtual device to find out the IP address of the new network interface that connects your device with the host machine. Run \emph{ping} from the host machine to test the connectivity with the virtual device. 

\item When starting a virtual device that is \emph{bridged} with the host computer, a new interface is also created on the host machine. In the lab environment, the name of this interface starts with \emph{docker}. The host machines \emph{beta-kathara} and \emph{gamma-kathara} do not have \emph{ifconfig} installed. Use instead the command \emph{ip address} and identify:
\begin{itemize}[label=-]
\item The IP address of the network interface connected to the virtual device.
\item The real IP address of the host computer (the IP address used in the Internet).
\end{itemize}
Test with \emph{ping} both addresses FROM the virtual device. 
\end{enumerate}

\subsection{Cleanup}

\begin{enumerate}[resume*]
\item Shutdown all the virtual devices you created during the lab. Use \emph{kathara wipe}.

\begin{lstlisting}
$ kathara wipe
Are you sure to wipe Kathara? (y/n) y
$ 
\end{lstlisting}
\end{enumerate}

\section{Exercises}

\begin{enumerate}
\item Start a virtual device named ``mypc'' using the \emph{kathara/base} image. Shut down the virtual device ``mypc''.
\item List the virtual devices started on your host machine (can be done on your personal installation of \kathara\ at home).
\item\label{redirect} Open a terminal window, which can be a terminal
  on the host machine or the terminal for a virtual machine. Run
  command \emph{ls $>$ listing.txt}, which redirects the output of command \emph{ls} to a file, which is, in this case, named \emph{listing.txt}. Examine the contents of the file using the commands \emph{cat} or \emph{less}. 

Check the manual page for command \emph{factor}. Run command \emph{factor} on an integer that has at least 6 digits and redirect the output to a text file named \emph{factors.txt} in your home directory. 

\item Start a virtual device. On the virtual device, run command \emph{ifconfig} and redirect its contents to a file in the work directory on your host machine. List the contents of the file from the host machine. You can use character $>$ followed by the file name to redirect the output of any command, from the console to the specified file (see Exercise \ref{redirect}).

\item Start a virtual device that is \emph{bridged} with the host computer. Find out the IPv6 addresses of the virtual device and the corresponding link local IPv6 address of the host machine. Use IPv6 with \emph{ping6} and perform the tasks below. Note that a link local IPv6 address can only be used to reach network interfaces on the same network, as its name suggests. Routing \footnote{Figuring out the particular network interface that a packet should be sent to in order to reach another network} ignores link local addresses, therefore we need to specify the network interface when using link local addresses. This is done by appending the network interface name to the link local IPv6 address using the \% notation, as in \lstinline$address%interface$. 
\begin{enumerate}[label=(\alph*)]
\item Test the connectivity via IPv6 with \emph{ping6}, from the host machine to the virtual device.
\item Test the connectivity via IPv6 with \emph{ping6}, from the virtual device to the host machine.
\item Are you able to \emph{ping6} the host machine from the virtual device using the link local IPv6 address of the host machine attached to the real network interface? Explain.
\item Are you able to \emph{ping6} the virtual device from the host machine using the link local IPv6 address of the virtual device but with the real network interface of the host machine after the \% character? Explain.
\end{enumerate}

\item Start a virtual device that is \emph{bridged} with the host computer. Start \emph{netcat} on the virtual device in listen mode. Send a message to the \emph{netcat} process on the virtual machine using \emph{netcat} on the host machine. For a short tutorial on \emph{netcat} and how to use it for chat, see \url{https://allabouttesting.org/netcat-tutorial-for-beginners/} or any other relevant online resource.
\end{enumerate}


%%%
\section{Part 2: network programming}

In this part of the lab, students will explore the programming libraries that will help them complete the project for the class. Network programming requires processing asynchronous events and this can be handled with multiple threads of execution. Threads can be avoided with advanced operating system calls such as \emph{select}, but I feel threads can be useful in other situations as well, so there is no harm in learning to program them. We start with basic multi-threaded programming and thread synchronization approaches. 

\subsection{Objectives}

Students will write a C++ program that starts several threads. The program will end when all threads end.

\begin{enumerate}[label=Objective \arabic*]
\item\label{thread.start} Using the C++ STL, students will write code that starts threads of execution.
\item\label{thread.sleep} Students will write code that can wait (sleep) for a given period of time.
\end{enumerate}


\subsection{Summary of routines}

\begin{tabularx}{\textwidth}{r  X}
  C++ Class or routine & Description \\ \midrule
  \lstinline$std::thread$ & spawns a new thread when a thread object is constructed  \\
  \lstinline$std::this_thread::sleep_for$ & puts currently running thread to sleep
\end{tabularx}

\subsection{Lab activities: warm-up}

\begin{enumerate}[label=Activity \arabic*:]
  
\item Consider the following output function:

  \begin{lstlisting}[language=C++]
    void print(int n, char c) {
      for (int i = 0; i < n; i++) {
        std::cout << c << ' ';
      }
    }
  \end{lstlisting}

  Examine the code and explain what this function does.

\item Create a working directory and a source file called \emph{sequential.cc} inside. Include the \emph{print} function and define \emph{main} to call \emph{print} twice. An example is shown below. Compile and execute your program.

  \begin{lstlisting}[language=c]
    int main() {
      print(100, 'a');
      print(100, 'b');
      return 0;
    }
  \end{lstlisting}
\end{enumerate}


\subsection{Lab activities: \ref{thread.sleep}}

  \begin{enumerate}[resume*]
  \item We can modify function print to slow it down a little. In the for loop of print, instruct the program to sleep for 50 ms after each output character. For example:
    
  \end{enumerate}

%%%%%%%%%%%%%%%%%

\chapter{Lab 2: creating networked devices}

\section{Objectives}

Students will start their first local network and will capture and analyse several network packets. 

\begin{enumerate}[label=Objective \arabic*]

\item\label{startstop} Students will start and stop kathara labs using provided lab files; students will work with a lab file that defines a simple local network with two virtual devices.

\item\label{ipv4.2} Students will start the lab and will configure IPv4 addresses on each of the virtual devices. 

\item\label{tcpdump}  Students will use the ping utility to test the local network connectivity between the two hosts created for the lab. Students will use the \emph{tcpdump} command to capture the packets generated by the \emph{ping} command; the students will examine the packets.

\item\label{modifylab} Using the kathara manual page \emph{man kathara-lab.conf}, the students will modify the lab files to add a third device to the network and to automatically configure IPv4 addresses on each device.

\item\label{ipv6.2}  Students will configure IPv6 addresses and will test the
  connectivity using \emph{ping6}. The students will examine the packets generated by the neighbour discovery protocol when IPv6 link local addresses are generated. 

%% \item Students will use the \emph{tcpdump} program to capture network
%%   packets. Students will examine captured packets with
%%   \emph{Wireshark} on their personal computers, or with an online
%%   network packet visualization tool such as
%%   \url{https://hpd.gasmi.net/}. Students will identify the protocols
%%   that participated in the creation of the captured packets. 
\end{enumerate}

\subsection{Summary of new commands}

\begin{tabularx}{\textwidth}{r  X}
  Commands & Description \\ \midrule
  unzip & unpacks the files from a zip archive \\
  tcpdump & captures traffic on a network interface \\
  arp & manipulates  or displays the kernel's IPv4 network neighbour cache \\ \midrule
  lstart & starts a \kathara\ lab \\
  lclean & shuts down a lab
\end{tabularx}


\subsection{Lab activities: \ref{startstop}}\label{2nodes.se}

\begin{enumerate}[label=Activity \arabic*:]
\item Open the Moodle page on the Lab section. Download the zip file titled \emph{kathara-lab2.zip} to a working directory and unpack the files using \emph{unzip}. 
  
\item Change your current directory to the folder where you unpacked
  the lab files. a folder names \emph{2nodes} should be present. Change into that folder. Run \emph{kathara lstart}. Two terminal windows should open, one for each of the two virtual devices.

  \begin{lstlisting}
$ cd 2nodes/
$ kathara lstart
======================= Starting Lab ========================
Name: 2 nodes
Description: Simple local network with two hosts and no network configuration
Version: 2.0
Author(s): Robert Benkoczi
Email: robert.benkoczi@uleth.ca

=============================================================
Deploying collision domains... |##########################################################################| 1/1
Deploying devices... |####################################################################################| 2/2
  \end{lstlisting}

\item Run \emph{ifconfig} on each of the two hosts. How many network interfaces does each device have? What are the IP addresses assigned to these network interfaces?

\item Labs created with \emph{lstart} can be stopped using command \emph{kathara lclean} executed from the lab directory. Try it now, shotdown the lab you just started.

  \begin{lstlisting}
$ kathara lclean
Deleting devices... |#####################################################################################| 2/2
Deleting collision domains... |###########################################################################| 1/1
  \end{lstlisting}

\end{enumerate}

\subsection{Target: \ref{ipv4.2}}\label{ipv4.2.se}
  
\begin{enumerate}[resume*]
\item The \emph{ifconfig} command is used to configure the network interface. Another commad that can be used is \emph{ip}. Invoke the manual (on the host machine) to read the documentation, if needed. Configure IPv4 address 10.0.0.1/24 on interface \emph{eth0} for device pc1, running \emph{ifconfig} as shown below.

  \begin{tabular}{r l}
    \toprule
    \multicolumn{2}{l}{\emph{ifconfig} arguments} \\ \midrule
    eth0 & interface name \\
    inet & (optional) address family: inet for IPv4, inet6 for IPv6 \\
    10.0.0.1/24 & IP address to configure \\ \bottomrule
  \end{tabular}

  \begin{lstlisting}
root@pc1:/# ifconfig eth0 inet 10.0.0.1/24
root@pc1:/# ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.0.0.1  netmask 255.255.255.0  broadcast 10.0.0.255
        inet6 fe80::f0f2:2bff:fed8:429d  prefixlen 64  scopeid 0x20<link>
        ether f2:f2:2b:d8:42:9d  txqueuelen 1000  (Ethernet)
        RX packets 66  bytes 9398 (9.1 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 7  bytes 826 (826.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
  \end{lstlisting}

  Note: We use the \emph{10.0.0} network address which is used for private networks (networks that are not expected to communicate with other hosts in the Internet \cite{rfc1918}. We assign host address 1 to pc1 and host address 2 to pc2.

\item Configure IPv4 address 10.0.0.2/24 on pc2.

  \end{enumerate}

%%%
\subsection{Target: \ref{tcpdump}}\label{tcpdump.se}

\begin{enumerate}[resume*]
\item Once the IPv4 addresses for the network interfaces on pc1 and pc2 are configured as documented in Section \ref{ipv4.2.se}, we can test the network connectivity with \emph{ping}. From pc1, we can ping pc2.

  \begin{lstlisting}
root@pc1:/# ping -c 4 10.0.0.2
PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.
64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=0.078 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=64 time=0.123 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=64 time=0.118 ms
64 bytes from 10.0.0.2: icmp_seq=4 ttl=64 time=0.122 ms

--- 10.0.0.2 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3062ms
rtt min/avg/max/mdev = 0.078/0.110/0.123/0.020 ms
  \end{lstlisting}

  %%%
\item We can examine the packets sent and received by \emph{ping} if we capture them using command \emph{tcpdump}:
\begin{enumerate}
\item Start the capture program \emph{tcpdump} on pc2.
\item Run \emph{ping} once more from pc1. Make sure you save the captured packets in a file in subdirectory \emph{/shared} on the virtual device. Files in folder \emph{/shared} on a virtual device are mapped to a folder named \emph{shared} in the lab folder on the host computer.
\item Interrupt the \emph{tcpdump} program on pc2 by pressing CTRL-C.
\end{enumerate}
  More information about \emph{tcpdump} is found in the manual pages \emph{man tcpdump} and several online articles \cite{tcpdump,tcpdump2}.

  \begin{tabularx}{0.9\textwidth}{r X} \toprule
    \multicolumn{2}{l}{\emph{tcpdump} arguments} \\ \midrule
    -i eth0 & which network interface to capture from \\
    -nn & -n tells not to resolve IP addresses into names; with -nn also does not resolve port numbers\\
    -s0 & -s sets the snap length; with 0 the length is unlimited \\
    -w filename & write capture to the specified file \\ \bottomrule
    \end{tabularx}

  \medskip
  \begin{lstlisting}
root@pc2:/# tcpdump -i eth0 -nn -s0 -w /shared/ping.pcap
tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
^C12 packets captured
12 packets received by filter
0 packets dropped by kernel
  \end{lstlisting}

\item\label{icmp} On the host machine, locate the captured file in folder \emph{shared} in the lab folder. Captured packets can be examined with \emph{Wireshark} (not available in the CS Lab) or with an online packet dissector.

  Open \url{https://hpd.gasmi.net} in a browser. Choose the upload button to upload your file with captured packets. Examine the packets, consult online resources, and try to answer the following questions.
  \begin{enumerate}[label=\roman*)]
  \item What protocol is \emph{ping} using? Explain the objectives of the protocol.
  \item Is the protocol using a specific port number? If yes, what number? Revisit the lecture notes from the first week which overview the services offered by the OSI layer and try to justify the choice for the protocol.
  \item Examine the header specific to the protocol used by \emph{ping}. Do you identify several types of packets for the protocol? If yes, list the types of packets and how they are distinguished.
  \end{enumerate}

\item Shutdown the lab. Use \emph{kathara lclean} with the lab directory as the current directory.

\end{enumerate}

%%%%%%%%%%%
\subsection{Target: \ref{modifylab}}

\begin{enumerate}[resume*]
\item First, please make sure no labs are currently running. Run \emph{kathara wipe} if unsure. Copy the directory structure of lab \emph{2nodes} to a different folder named \emph{3nodes}. change the current directory to folder \emph{3nodes}.

  \begin{lstlisting}
$ kathara lclean
A new version of Kathara has been released.
Current: 3.1.0 - Latest: 3.2.0
Please update it from https://github.com/KatharaFramework/Kathara
Deleting devices... |#####################################################################################| 2/2
Deleting collision domains... |###########################################################################| 1/1
$ cd ..
$ ls
2nodes/  2nodes.config  2nodes-ipv6.config  2nodes.zip
$ cp -r 2nodes 3nodes
$ ls
2nodes/  2nodes.config  2nodes-ipv6.config  2nodes.zip  3nodes/
$ cd 3nodes/
$ ls
lab.conf  pc1/  pc1.startup  pc2/  pc2.startup  shared/
  \end{lstlisting}

\item Open \emph{lab.conf} with a text editor. In a different terminal window, open the manual page for \kathara\ labs, \emph{man kathara-lab.conf}. The \emph{lab.conf} sets up the structure of the network. It specifies the hosts (virtual devices), network interfaces, and the collision domains (Ethernet switches) that make up the lab.

  Configurations for each host can be defined in files with extension \emph{.startup}. For example, we will add IPv4 address configuration commands in these files.

  The contents of the \emph{lab.conf} file is the following.

  \lstinputlisting{kathara-labs/2nodes/lab.conf}

  Modify \emph{lab.conf} and add a third host named \emph{pc3} connected to the same collision domain as \emph{pc1} and \emph{pc2}. Also edit the lab metadata, such as title, author, etc.

\item Edit the startup files for \emph{pc1} and \emph{pc2} and add the \emph{ifconfig} command that assigns the appropriate IPv4 addresses to the two hosts. The correct command is already present, in commented form. Uncommend the command. Add the configuration file for \emph{pc3} and assign address 10.0.0.3/24 to \emph{pc3}.

\item Start the new lab. Test if \emph{pc3} is connected to the network. Debug and adjust the lab files if necessary.

\end{enumerate}


%%%
\subsection{Target: \ref{ipv6.2}}\label{ipv6.2.se}

\begin{enumerate}[resume*]
\item Ensure that your lab named \emph{3nodes} is running. Look at the network interface \emph{eth0} for one of the virtual hosts and list the addresses associated with the interface. Are there any global IPv6 addresses assigned to the interface?

\item Run \emph{ping6} from \emph{pc3} to query the connectivity to \emph{pc1}. What is the correct argument to the command?

\item Assign the global IPv6 address 2100::1/64 to \emph{pc1}. Use command \emph{ifconfig} but provide \emph{inet6} as the address family. Note that IPv6 addresses can be added to an interface, but the command must specify the option \emph{add} folowed by the address. Similarly, IPv6 addresses can be deleted from an interface. See the man pages \emph{man ifconfig}.

  \begin{lstlisting}
root@pc1:/# ifconfig eth0 inet6 add 2100::1/64
root@pc1:/# ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 10.0.0.1  netmask 255.255.255.0  broadcast 10.0.0.255
        inet6 fe80::acc1:d4ff:fe1d:b075  prefixlen 64  scopeid 0x20<link>
        inet6 2100::1  prefixlen 64  scopeid 0x0<global>
        ether ae:c1:d4:1d:b0:75  txqueuelen 1000  (Ethernet)
        RX packets 98  bytes 13730 (13.4 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 16  bytes 1896 (1.8 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 4  bytes 280 (280.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 4  bytes 280 (280.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
  \end{lstlisting}

\item Ping6 again from \emph{pc3} to query if \emph{pc1} is connected, but use this time \emph{pc1}'s global address, 2100::1. Can the command be completed? Explain why, or why not.

\item Assign global IPv6 addresses 2100::2/64 and 2100::3/64 to \emph{pc2} and \emph{pc3}, respectively. Try now to ping6 \emph{pc1} from \emph{pc3} using \emph{pc1}'s global IPv6 address. Does the command succeed this time?

  \item Edit the lab files for lab \emph{3nodes} on the host machine so that \emph{pc1}, \emph{pc2}, and \emph{pc3} are automatically assigned the global IPv6 addresses 2100::1, 2100::2, and 2100::3 respectively.
\end{enumerate}

\subsection{Cleanup}

\begin{enumerate}[resume*]
\item The most important activity: before you log out, shutdown any running labs. If you are unsure about which labs you are running, execute \emph{kathara wipe}.
\end{enumerate}


%%%%%%%%
\section{Exercises}

\begin{enumerate}
\item Start your \emph{3nodes} lab with hosts being assigned IPv4 and global IPv6 addresses. Start packet capture on \emph{pc3} and run \emph{ping6} from \emph{pc1} to \emph{pc2}, using link local and then the global IPv6 addresses (see Section \ref{tcpdump.se}). Examine the packets used by \emph{ping6} and compare them with the packets captured for IPv4 in Section \ref{tcpdump.se}. Shutdown the lab at the end.
  
\item With your lab \emph{3nodes} started, run \emph{netcat} over the global IPv6 addresses and send a message from one host to another one. Use UDP or TCP. Shutdown the lab at the end.

\item\label{arp} ARP (Address Resolution Protocol) or how the connection between link layer (Ethernet) and network layer (IPv4) addresses is made. Recall the captured packets for \emph{ping} you obtained in Section \ref{tcpdump.se}. If you re-examine one packet, you notice that the IPv4 header contains the source and destination IPv4 address, and the Ethernet header contains the source and destination Ethernet address. When the networking stack creates this packet at the source host, it definitely knows the source and destination IPv4 addresses (the destination is given in the \emph{ping} command), and it also knows its own source Ethernet address. But how can it obtain the destination Ethernet address corresponding to the destination IPv4 address? You will answer this question in this exercise.

  Perform the following steps.
  \begin{enumerate}[label=(\roman*)]
  \item\label{first.1} Start lab \emph{3nodes}.
  \item Start packet capture with \emph{tcpdump} on, say \emph{pc3}. Remember to save the captured packets in the \emph{/shared} folder on \emph{pc3}.
  \item The operating system maintains a table of neighbour IPv4 / Ethernet addresses called the network neighbour cache. The \emph{arp} command is used to manipulate this table. Examine the manual pages for \emph{arp} (\url{https://www.man7.org/linux/man-pages/man8/arp.8.html} if man arp is not available on the host machine).

    \smallskip
    \begin{tabularx}{0.9\textwidth}{r l} \toprule
      \multicolumn{2}{l}{\emph{arp} command line arguments} \\ \midrule
      $\emptyset$ (no args) & displays the contents of the table \\
      -d address & deletes the  entry corresponding to \emph{address} \\ \bottomrule
    \end{tabularx}
    \smallskip

    Show the arp table from host \emph{pc1}. If it is empty, good!
    
  \item From \emph{pc1}, \emph{ping} \emph{pc2} and show again the arp table from host \emph{pc1}. It should have now an entry for \emph{pc2}'s IPv4 address. This means that your captured packets will show how the data for this new entry was obtained.
    
  \item (optional) If the arp table was not empty before you started the capture, delete the arp entry in \emph{pc1}'s table for \emph{pc2}. Then, from \emph{pc1}, \emph{ping} \emph{pc2}.

  \item\label{last.1} Stop the packet capture, and shutdown the lab. Examine the captured packets with   \url{https://hpd.gasmi.net}.
  \end{enumerate}

  Submit the following:
  \begin{enumerate}[label=(\alph*)]
  \item A briefly commented script corresponding to your commands for steps \ref{first.1} to \ref{last.1} together with the output. Your comments should indicate your purpose for each command.
  \item Explain when entries in the arp table are populated. For example, is the table populated when the host starts up? Is it populated on demand? Etc.
  \item Examine the file with captured packets (.pcap file). Which hosts have placed an ARP request? List the packets containing the ARP request as decoded     by your network packet examination utility.
    \item Examine the pcap file. Which hosts answer each ARP request?
      How is the ARP request delivered and what IPv4
      address is used?
  \item Assume \emph{pc3}'s arp table is empty and, from \emph{pc3}, we \emph{ping} \emph{pc2}. Briefly describe how the ARP packets are exchanged. 
  \end{enumerate}

  %%%%%%%% IPv6 neighbour discovery
\item NDP (Neighbour Discovery Protocol) is a protocol that allows one host to discover the link layer (Ethernet typically) address corresponding to an IPv6 address for a host on the same local network. This exercise is similar to Exercise \ref{arp} but for IPv6 and NDP.

The neighbours table for IPv6 can be examined and manipulated with command \emph{ip}. Please see \url{https://www.linuxtopia.org/online_books/network_administration_guides/Linux+IPv6-HOWTO/Linux_IPv6_HowTo_x1187.html} and also the manual pages, \emph{man ip}.

\smallskip
\begin{tabularx}{0.9\textwidth}{p{5cm} X} \toprule
  \multicolumn{2}{l}{\emph{ip} command line arguments} \\ \midrule
  -6 & use the IPv6 protocol family \\
  neigh & the object manipulated is the neighbours table \\
  show & is a command; it displays the neighbours table \\
  (add/del) IPv6addr lladdr Etheraddr dev device & is a command; it  (adds/deletes) an entry with the specified IPv6 and Ethernet addresses on the given interface\\ \bottomrule
  \end{tabularx}
\smallskip

  Perform the following steps.
  \begin{enumerate}[label=(\roman*)]
  \item Start lab \emph{3nodes}.
  \item Start packet capture with \emph{tcpdump} on, say \emph{pc3}. Remember to save the captured packets in the \emph{/shared} folder on \emph{pc3}.
  \item Examine the contents of the neighbours table on \emph{pc1}.
  \item Make sure there is no entry for \emph{pc2}'s IPv6 address. If there is, delete the entry with \emph{ip -6 neigh del 2100::2 lladdr <Ethernet addr> dev eth0}.
  \item ping6 \emph{pc2} from \emph{pc1}.
  \item Show the neighbours table.
  \item Stop the capture on \emph{pc3}.
    \item Open the pcap file with the online packet reader. 
  \end{enumerate}

      \smallskip
      Submit the following:
  \begin{enumerate}[label=(\alph*)]
  \item A briefly commented script showing your commands described above.
  \item Select the first neighbour solicitation packet. What are the source and destination IPv6 addresses. How about the source and destination Ethernet addresses?
    Consult \url{https://www.computernetworkingnotes.com/networking-tutorials/ipv6-multicast-addresses-explained.html}.
    \item What are the source and destination IP addresses for the reply? Where is the answer stored?
  \end{enumerate}
\end{enumerate}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Lab 3: manual routing tables}

\section{Objectives}

Students will set up routing tables manually so that packets can be exchanged between the three local networks.

\begin{enumerate}[label=Objective \arabic*:]
\item\label{unu} Students will examine the default (empty) routing tables for the lab.
\item\label{addroute} Students will manually add entries in the routing tables to ensure connectivity between LANs.
\item\label{addipv6} Students will configure the lab with IPv6 addresses and restart the lab.
\item\label{ipv6route} Students will populate the routing table for IPv6 using \emph{default} rules. 
\end{enumerate}


\subsection{Summary of new commands}

\begin{tabularx}{\textwidth}{r  X}
  Commands & Description \\ \midrule
  route & displays and modifies routing tables; \emph{man route} for details \\
  route -6 & displays and modifies IPv6 routing tables\\
\end{tabularx}


\section{Lab activities}

%%%
\subsection{Target: \ref{unu}}

\inspdf{1}{1}{Configuration of lab ``3lans''}

\begin{enumerate}[label=Activity \arabic*:]
\item Examine Fig. \ref{f-1} which shows the structure of the network. There are three local networks illustrated by the three edges in the graph. The hosts are represented by rectangles. Each edge (network) is incident to a rectangle to signify that the host is connected to the respective network. The point of incidence represents the host's interface on that network.

  The network prefix for each network is given next to the corresponding edge in the diagram. The host suffix of the IPv4 addresses for each interface is given next to the point representing the interface. The address of an interface is obtained by concatenating the network prefix with the host suffix. For example the IPv4 address of \emph{eth0} for \emph{pc1} is 55.0.0.2.

  What is the address for \emph{eth0} and \emph{eth1} for \emph{r2}?

\item Download the lab files for the lab titled ``3lans'' from the Moodle page and unpack them in a working directory from your account. Start the lab. Examine the IPv4 addresses assigned to the interfaces of virtual devices \emph{pc1} and \emph{r2} and check if they match the diagram in Fig.~\ref{f-1}.

\item From \emph{pc1} ping \emph{r1} using \emph{r1}'s eth0 interface which is connected on the same network. From \emph{pc1} ping \emph{r1}'s eth1 interface. Explain the results. Run \emph{route} to examine the routing tables.
  \begin{lstlisting}
root@pc1:/# ping -c 3 55.0.0.1
PING 55.0.0.1 (55.0.0.1) 56(84) bytes of data.
64 bytes from 55.0.0.1: icmp_seq=1 ttl=64 time=0.238 ms
64 bytes from 55.0.0.1: icmp_seq=2 ttl=64 time=0.109 ms
64 bytes from 55.0.0.1: icmp_seq=3 ttl=64 time=0.136 ms

--- 55.0.0.1 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2027ms
rtt min/avg/max/mdev = 0.109/0.161/0.238/0.055 ms
root@pc1:/# ping -c 3 10.0.0.1
connect: Network is unreachable
root@pc1:/# ^C
root@pc1:/# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
55.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0
root@pc1:/#
  \end{lstlisting}

\item From \emph{r1} ping \emph{pc1} (eth0) and \emph{r2} (eth1). Can \emph{r1} ping \emph{r2}'s eth0? Explain. 

  \begin{lstlisting}
root@r1:/# ping 55.0.0.2
PING 55.0.0.2 (55.0.0.2) 56(84) bytes of data.
64 bytes from 55.0.0.2: icmp_seq=1 ttl=64 time=0.161 ms
64 bytes from 55.0.0.2: icmp_seq=2 ttl=64 time=0.116 ms
64 bytes from 55.0.0.2: icmp_seq=3 ttl=64 time=0.123 ms
^C
--- 55.0.0.2 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2045ms
rtt min/avg/max/mdev = 0.116/0.133/0.161/0.021 ms
root@r1:/# ping -c3 10.0.0.2
PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.
64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=0.073 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=64 time=0.109 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=64 time=0.117 ms

--- 10.0.0.2 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2029ms
rtt min/avg/max/mdev = 0.073/0.099/0.117/0.022 ms
root@r1:/# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth1
55.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0
  \end{lstlisting}
\end{enumerate}


%%%
\subsection{Target: \ref{addroute}}\label{route.ipv4.3.se}

\begin{enumerate}[resume*]
\item We noticed that packets can be sent from a host to destinations that have entries in the routing table (as expected). So, to ping \emph{r1}'s interface eth1 from \emph{pc1}, the routing table at \emph{pc1} should have an entry for \emph{r1}'s eth1 interface, or it should have a default entry (if no matches by other rules, use the default rule to route packets.

  Add an entry for network 10.0.0.0/24 on \emph{pc1}. From \emph{pc1} ping \emph{r1}'s eth1. Do we have success? Why?

  \begin{lstlisting}
root@pc1:/# route add -net 10.0.0.0 netmask 255.255.255.0 gw 55.0.0.1
root@pc1:/# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        55.0.0.1        255.255.255.0   UG    0      0        0 eth0
55.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0
root@pc1:/# ping -c 3 10.0.0.1
PING 10.0.0.1 (10.0.0.1) 56(84) bytes of data.
64 bytes from 10.0.0.1: icmp_seq=1 ttl=64 time=0.178 ms
64 bytes from 10.0.0.1: icmp_seq=2 ttl=64 time=0.118 ms
64 bytes from 10.0.0.1: icmp_seq=3 ttl=64 time=0.116 ms

--- 10.0.0.1 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2052ms
rtt min/avg/max/mdev = 0.116/0.137/0.178/0.030 ms
  \end{lstlisting}

\item We can also configure \emph{pc2}'s routing table so that it can ping \emph{r2}'s interfaces, but this time, add a default entry on \emph{pc2}'s routing table..

  \begin{lstlisting}
root@pc1:/# route add -net 10.0.0.0 netmask 255.255.255.0 gw 55.0.0.1
root@pc1:/# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        55.0.0.1        255.255.255.0   UG    0      0        0 eth0
55.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0
root@pc1:/# ping -c 3 10.0.0.1
PING 10.0.0.1 (10.0.0.1) 56(84) bytes of data.
64 bytes from 10.0.0.1: icmp_seq=1 ttl=64 time=0.178 ms
64 bytes from 10.0.0.1: icmp_seq=2 ttl=64 time=0.118 ms
64 bytes from 10.0.0.1: icmp_seq=3 ttl=64 time=0.116 ms

--- 10.0.0.1 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2052ms
rtt min/avg/max/mdev = 0.116/0.137/0.178/0.030 ms
  \end{lstlisting}

\item We can get more daring. From \emph{pc2} ping \emph{r1}'s eth1 interface. What is happening and why?
  \begin{lstlisting}
root@pc2:/# ping -c3 10.0.0.2
PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.
64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=0.060 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=64 time=0.127 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=64 time=0.128 ms

--- 10.0.0.2 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2040ms
rtt min/avg/max/mdev = 0.060/0.105/0.128/0.031 ms
root@pc2:/# ping -c3 10.0.0.1
PING 10.0.0.1 (10.0.0.1) 56(84) bytes of data.
^C
--- 10.0.0.1 ping statistics ---
3 packets transmitted, 0 received, 100% packet loss, time 2041ms
  \end{lstlisting}

\item So, from \emph{pc2} we can reach r2's interface eth1, but we cannot reach \emph{r1}'s eth1 interface. We see that we, in fact, do reach \emph{r2}'s interface eth1, but the reply from \emph{r1} does not reach \emph{pc2}. We verify this with \emph{tcpdump} from \emph{r1}:

  \begin{lstlisting}
root@r1:/# tcpdump -i eth1
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth1, link-type EN10MB (Ethernet), capture size 262144 bytes
07:39:53.457676 IP 77.0.0.2 > 10.0.0.1: ICMP echo request, id 49, seq 1, length 64
07:39:54.483611 IP 77.0.0.2 > 10.0.0.1: ICMP echo request, id 49, seq 2, length 64
07:39:55.507639 IP 77.0.0.2 > 10.0.0.1: ICMP echo request, id 49, seq 3, length 64
07:39:58.579572 ARP, Request who-has 10.0.0.1 tell 10.0.0.2, length 28
07:39:58.579604 ARP, Reply 10.0.0.1 is-at f2:d1:bf:63:2a:b2 (oui Unknown), length 28
  \end{lstlisting}

\item Fix the routing tables by adding the appropriate entry for 77.0.0.0/24 on \emph{r1}. 
  \begin{lstlisting}
root@r1:/# route add -net 77.0.0.0 netmask 255.255.255.0 gw 10.0.0.2

root@pc2:/# ping -c3 10.0.0.1
PING 10.0.0.1 (10.0.0.1) 56(84) bytes of data.
64 bytes from 10.0.0.1: icmp_seq=1 ttl=63 time=0.205 ms
64 bytes from 10.0.0.1: icmp_seq=2 ttl=63 time=0.138 ms
64 bytes from 10.0.0.1: icmp_seq=3 ttl=63 time=0.138 ms

--- 10.0.0.1 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2038ms
rtt min/avg/max/mdev = 0.138/0.160/0.205/0.033 ms
  \end{lstlisting}

\item Similarly, add an appropriate entry for 55.0.0.0/24 in \emph{r2}'s routing table, so that we can ping \emph{r2}'s eth0 from \emph{pc1}. 

\item Can we now ping \emph{pc2} from \emph{pc1}? What is the state of the routing tables? Do you spot the problem?
  \begin{lstlisting}
root@pc1:/# ping -c 3 77.0.0.2
connect: Network is unreachable
root@pc1:/# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        55.0.0.1        255.255.255.0   UG    0      0        0 eth0
55.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0

root@pc2:/# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         77.0.0.1        0.0.0.0         UG    0      0        0 eth0
77.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0

root@r1:/# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth1
55.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0
77.0.0.0        10.0.0.2        255.255.255.0   UG    0      0        0 eth1

root@r2:/# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth1
55.0.0.0        10.0.0.1        255.255.255.0   UG    0      0        0 eth1
77.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0
  \end{lstlisting}

\item Notice that \emph{pc1} does not know how to route packets for 77.0.0.0/24. We can add an entry for 77.0.0.0/24, or we can replace the entry for 10.0.0.0/24 with a default rule, like for \emph{pc2}.
  \begin{lstlisting}
root@pc1:/# route add -net 77.0.0.0 netmask 255.255.255.0 gw 55.0.0.1
root@pc1:/# ping -c 3 77.0.0.2
PING 77.0.0.2 (77.0.0.2) 56(84) bytes of data.
64 bytes from 77.0.0.2: icmp_seq=1 ttl=62 time=0.086 ms
64 bytes from 77.0.0.2: icmp_seq=2 ttl=62 time=0.062 ms
64 bytes from 77.0.0.2: icmp_seq=3 ttl=62 time=0.121 ms

--- 77.0.0.2 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2037ms
rtt min/avg/max/mdev = 0.062/0.089/0.121/0.026 ms
  \end{lstlisting}

  \item Verify that \emph{pc1} and \emph{pc2} can ping each other. If yes, you have correctly set-up the routing tables for this small network of LANs.
\end{enumerate}

%%
\subsection{Cleanup}

\begin{enumerate}[resume*]
\item The most important activity: before you log out, shutdown any running labs. If you are unsure about which labs you are running, execute \emph{kathara wipe}.
\end{enumerate}

%%%%%%%%%%

\section{Exercises}

\begin{enumerate}
\item Start lab ``3lans''. Can you configure the routing tables for all four devices  using only default rules in such a way that \emph{pc1} is connected to \emph{pc2} and vice-versa?

\item\label{ipv6.3.ex} (Target: \ref{addipv6}) Copy the lab files for ``3lans'' into a new directory named ``3lans.ipv6''. Assign the following IPv6 addresses to the three networks by editing the startup files for the lab (see Section \ref{ipv6.2.se}). The host suffix for the IPv6 addresses should match the host suffix for the IPv4 addresses.

  \begin{tabular}{l l} \toprule
    IPv4 address  & IPv6 address \\ \midrule
    55.0.0.0/24 & 2055::0/64 \\
    10.0.0.0/24 & 2010::0/64 \\
    77.0.0.0/24 & 2077::0/64\\ \bottomrule
  \end{tabular}

  Start lab ``3lans.ipv6'' and ping6 across the local networks to demonstrate that interfaces were correctly set up. Shutdown the lab when done.

\item (Target: \ref{ipv6route}) Start lab ``3lans.ipv6'' (see Exercise \ref{ipv6.3.ex}).
  \begin{enumerate}[label=(\alph*)]
  \item Verify that IPv6 addresses are set appropriately using \emph{ifconfig}. Display the IPv6 routing tables with \emph{route -6}.
  \item Run the lab activities from Section \ref{route.ipv4.3.se} but for IPv6 this time. An example setting the default IPv6 route for \emph{pc1} is given below.
    \begin{lstlisting}
root@pc1:/# ifconfig eth0
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 55.0.0.2  netmask 255.255.255.0  broadcast 55.0.0.255
        inet6 fe80::b425:89ff:fe2e:c35  prefixlen 64  scopeid 0x20<link>
        inet6 2055::2  prefixlen 64  scopeid 0x0<global>
        ether b6:25:89:2e:0c:35  txqueuelen 1000  (Ethernet)
        RX packets 53  bytes 7878 (7.6 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 9  bytes 1122 (1.0 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

root@pc1:/# ping6 -c 3 2055::1
PING 2055::1(2055::1) 56 data bytes
64 bytes from 2055::1: icmp_seq=1 ttl=64 time=0.056 ms
64 bytes from 2055::1: icmp_seq=2 ttl=64 time=0.103 ms
64 bytes from 2055::1: icmp_seq=3 ttl=64 time=0.114 ms

--- 2055::1 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2053ms
rtt min/avg/max/mdev = 0.056/0.091/0.114/0.025 ms
root@pc1:/# ping6 -c 3 2010::1
connect: Network is unreachable
root@pc1:/# route -6 add default gw 2055::1
root@pc1:/# ping6 -c 3 2010::1
PING 2010::1(2010::1) 56 data bytes
64 bytes from 2010::1: icmp_seq=1 ttl=64 time=0.099 ms
64 bytes from 2010::1: icmp_seq=2 ttl=64 time=0.095 ms
64 bytes from 2010::1: icmp_seq=3 ttl=64 time=0.110 ms

--- 2010::1 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2051ms
rtt min/avg/max/mdev = 0.095/0.101/0.110/0.010 ms
    \end{lstlisting}
    
  \item Demonstrate that \emph{pc1} can ping6 \emph{pc2}.
  \end{enumerate}
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\bibliographystyle{plain} \bibliography{labman}

\end{document}
